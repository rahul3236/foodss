{"version":3,"file":"slate.es.js","sources":["../src/utils/mixin.js","../src/utils/key-utils.js","../src/constants/model-types.js","../src/models/data.js","../src/models/document.js","../src/models/inline.js","../src/models/mark.js","../src/models/leaf.js","../src/utils/memoize.js","../src/models/text.js","../src/models/node.js","../src/models/block.js","../src/changes/at-current-range.js","../src/utils/text-utils.js","../src/changes/at-range.js","../src/utils/path-utils.js","../src/changes/by-path.js","../src/models/point.js","../src/models/decoration.js","../src/models/range.js","../src/models/selection.js","../src/models/history.js","../src/models/stack.js","../src/utils/slate-error.js","../src/models/schema.js","../src/models/value.js","../src/models/operation.js","../src/operations/invert.js","../src/changes/on-history.js","../src/changes/on-selection.js","../src/changes/on-value.js","../src/changes/with-schema.js","../src/changes/index.js","../src/operations/apply.js","../src/models/change.js","../src/interfaces/common.js","../src/interfaces/element.js","../src/interfaces/node.js","../src/interfaces/range.js","../src/operations/index.js","../src/index.js"],"sourcesContent":["/**\n * Mix in an `Interface` to a `Class`.\n *\n * @param {Class} Class\n * @param {Class} Interface\n */\n\nexport default function mixin(Interface, Classes) {\n  for (const Class of Classes) {\n    for (const name of Object.getOwnPropertyNames(Interface)) {\n      if (Class.hasOwnProperty(name)) continue\n      const desc = Object.getOwnPropertyDescriptor(Interface, name)\n      Object.defineProperty(Class, name, desc)\n    }\n\n    for (const name of Object.getOwnPropertyNames(Interface.prototype)) {\n      if (Class.prototype.hasOwnProperty(name)) continue\n      const desc = Object.getOwnPropertyDescriptor(Interface.prototype, name)\n      Object.defineProperty(Class.prototype, name, desc)\n    }\n  }\n}\n","/**\n * An auto-incrementing index for generating keys.\n *\n * @type {Number}\n */\n\nlet n\n\n/**\n * The global key generating function.\n *\n * @type {Function}\n */\n\nlet generate\n\n/**\n * Create a key, using a provided key if available.\n *\n * @param {String|Void} key\n * @return {String}\n */\n\nfunction create(key) {\n  if (key == null) {\n    return generate()\n  }\n\n  if (typeof key === 'string') {\n    return key\n  }\n\n  throw new Error(`Keys must be strings, but you passed: ${key}`)\n}\n\n/**\n * Set a different unique ID generating `function`.\n *\n * @param {Function} func\n */\n\nfunction setGenerator(func) {\n  generate = func\n}\n\n/**\n * Reset the key generating function to its initial state.\n */\n\nfunction resetGenerator() {\n  n = 0\n  generate = () => `${n++}`\n}\n\n/**\n * Set the initial state.\n */\n\nresetGenerator()\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  create,\n  setGenerator,\n  resetGenerator,\n}\n","/**\n * Slate-specific model types.\n *\n * @type {Object}\n */\n\nconst MODEL_TYPES = {\n  BLOCK: '@@__SLATE_BLOCK__@@',\n  CHANGE: '@@__SLATE_CHANGE__@@',\n  DECORATION: '@@__SLATE_DECORATION__@@',\n  DOCUMENT: '@@__SLATE_DOCUMENT__@@',\n  HISTORY: '@@__SLATE_HISTORY__@@',\n  INLINE: '@@__SLATE_INLINE__@@',\n  LEAF: '@@__SLATE_LEAF__@@',\n  MARK: '@@__SLATE_MARK__@@',\n  OPERATION: '@@__SLATE_OPERATION__@@',\n  POINT: '@@__SLATE_POINT__@@',\n  RANGE: '@@__SLATE_RANGE__@@',\n  SCHEMA: '@@__SLATE_SCHEMA__@@',\n  SELECTION: '@@__SLATE_SELECTION__@@',\n  STACK: '@@__SLATE_STACK__@@',\n  TEXT: '@@__SLATE_TEXT__@@',\n  VALUE: '@@__SLATE_VALUE__@@',\n}\n\n/**\n * Export type identification function\n *\n * @param {string} type\n * @param {any} any\n * @return {boolean}\n */\n\nexport function isType(type, any) {\n  return !!(any && any[MODEL_TYPES[type]])\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default MODEL_TYPES\n","import isPlainObject from 'is-plain-object'\nimport { Map } from 'immutable'\n\n/**\n * Data.\n *\n * This isn't an immutable record, it's just a thin wrapper around `Map` so that\n * we can allow for more convenient creation.\n *\n * @type {Object}\n */\n\nclass Data {\n  /**\n   * Create a new `Data` with `attrs`.\n   *\n   * @param {Object|Data|Map} attrs\n   * @return {Data} data\n   */\n\n  static create(attrs = {}) {\n    if (Map.isMap(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Data.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Data.create\\` only accepts objects or maps, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Data` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Data}\n   */\n\n  static fromJSON(object) {\n    return new Map(object)\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Data.fromJSON\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Data\n","import isPlainObject from 'is-plain-object'\nimport { List, Map, Record } from 'immutable'\n\nimport KeyUtils from '../utils/key-utils'\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport Node from './node'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  key: undefined,\n  nodes: new List(),\n}\n\n/**\n * Document.\n *\n * @type {Document}\n */\n\nclass Document extends Record(DEFAULTS) {\n  /**\n   * Create a new `Document` with `attrs`.\n   *\n   * @param {Object|Array|List|Text} attrs\n   * @return {Document}\n   */\n\n  static create(attrs = {}) {\n    if (Document.isDocument(attrs)) {\n      return attrs\n    }\n\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      attrs = { nodes: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Document.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Document.create\\` only accepts objects, arrays, lists or documents, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Document` from a JSON `object`.\n   *\n   * @param {Object|Document} object\n   * @return {Document}\n   */\n\n  static fromJSON(object) {\n    if (Document.isDocument(object)) {\n      return object\n    }\n\n    const { data = {}, key = KeyUtils.create(), nodes = [] } = object\n\n    const document = new Document({\n      key,\n      data: new Map(data),\n      nodes: Node.createList(nodes),\n    })\n\n    return document\n  }\n\n  /**\n   * Check if `any` is a `Document`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isDocument = isType.bind(null, 'DOCUMENT')\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'document'\n  }\n\n  /**\n   * Return a JSON representation of the document.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nDocument.prototype[MODEL_TYPES.DOCUMENT] = true\n\n/**\n * Export.\n *\n * @type {Document}\n */\n\nexport default Document\n","import isPlainObject from 'is-plain-object'\nimport { List, Map, Record } from 'immutable'\n\nimport KeyUtils from '../utils/key-utils'\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport Node from './node'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  key: undefined,\n  nodes: new List(),\n  type: undefined,\n}\n\n/**\n * Inline.\n *\n * @type {Inline}\n */\n\nclass Inline extends Record(DEFAULTS) {\n  /**\n   * Create a new `Inline` with `attrs`.\n   *\n   * @param {Object|String|Inline} attrs\n   * @return {Inline}\n   */\n\n  static create(attrs = {}) {\n    if (Inline.isInline(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Inline.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Inline.create\\` only accepts objects, strings or inlines, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Inlines` from an array.\n   *\n   * @param {Array<Inline|Object>|List<Inline|Object>} elements\n   * @return {List<Inline>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Inline.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Inline.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Inline` from a JSON `object`.\n   *\n   * @param {Object|Inline} object\n   * @return {Inline}\n   */\n\n  static fromJSON(object) {\n    if (Inline.isInline(object)) {\n      return object\n    }\n\n    const { data = {}, key = KeyUtils.create(), nodes = [], type } = object\n\n    if (typeof type != 'string') {\n      throw new Error('`Inline.fromJS` requires a `type` string.')\n    }\n\n    const inline = new Inline({\n      key,\n      type,\n      data: new Map(data),\n      nodes: Node.createList(nodes),\n    })\n\n    return inline\n  }\n\n  /**\n   * Check if `any` is a `Inline`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isInline = isType.bind(null, 'INLINE')\n\n  /**\n   * Check if `any` is a list of inlines.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isInlineList(any) {\n    return List.isList(any) && any.every(item => Inline.isInline(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'inline'\n  }\n\n  /**\n   * Return a JSON representation of the inline.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      type: this.type,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nInline.prototype[MODEL_TYPES.INLINE] = true\n\n/**\n * Export.\n *\n * @type {Inline}\n */\n\nexport default Inline\n","import isPlainObject from 'is-plain-object'\nimport { Map, Record, Set } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport Data from './data'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  type: undefined,\n}\n\n/**\n * Mark.\n *\n * @type {Mark}\n */\n\nclass Mark extends Record(DEFAULTS) {\n  /**\n   * Create a new `Mark` with `attrs`.\n   *\n   * @param {Object|Mark} attrs\n   * @return {Mark}\n   */\n\n  static create(attrs = {}) {\n    if (Mark.isMark(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Mark.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Mark.create\\` only accepts objects, strings or marks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a set of marks.\n   *\n   * @param {Array<Object|Mark>} elements\n   * @return {Set<Mark>}\n   */\n\n  static createSet(elements) {\n    if (Set.isSet(elements) || Array.isArray(elements)) {\n      const marks = new Set(elements.map(Mark.create))\n      return marks\n    }\n\n    if (elements == null) {\n      return Set()\n    }\n\n    throw new Error(\n      `\\`Mark.createSet\\` only accepts sets, arrays or null, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable mark properties from `attrs`.\n   *\n   * @param {Object|String|Mark} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Mark.isMark(attrs)) {\n      return {\n        data: attrs.data,\n        type: attrs.type,\n      }\n    }\n\n    if (typeof attrs == 'string') {\n      return { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('type' in attrs) props.type = attrs.type\n      if ('data' in attrs) props.data = Data.create(attrs.data)\n      return props\n    }\n\n    throw new Error(\n      `\\`Mark.createProperties\\` only accepts objects, strings or marks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Mark` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Mark}\n   */\n\n  static fromJSON(object) {\n    const { data = {}, type } = object\n\n    if (typeof type != 'string') {\n      throw new Error('`Mark.fromJS` requires a `type` string.')\n    }\n\n    const mark = new Mark({\n      type,\n      data: new Map(data),\n    })\n\n    return mark\n  }\n\n  /**\n   * Check if `any` is a `Mark`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isMark = isType.bind(null, 'MARK')\n\n  /**\n   * Check if `any` is a set of marks.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isMarkSet(any) {\n    return Set.isSet(any) && any.every(item => Mark.isMark(item))\n  }\n\n  /**\n   * Object.\n   */\n\n  get object() {\n    return 'mark'\n  }\n\n  /**\n   * Return a JSON representation of the mark.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      type: this.type,\n      data: this.data.toJSON(),\n    }\n\n    return object\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nMark.prototype[MODEL_TYPES.MARK] = true\n\n/**\n * Export.\n *\n * @type {Mark}\n */\n\nexport default Mark\n","import isPlainObject from 'is-plain-object'\nimport { List, Record, Set } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport Mark from './mark'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  marks: Set(),\n  text: '',\n}\n\n/**\n * Leaf.\n *\n * @type {Leaf}\n */\n\nclass Leaf extends Record(DEFAULTS) {\n  /**\n   * Create a new `Leaf` with `attrs`.\n   *\n   * @param {Object|Leaf} attrs\n   * @return {Leaf}\n   */\n\n  static create(attrs = {}) {\n    if (Leaf.isLeaf(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { text: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Leaf.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Leaf.create\\` only accepts objects, strings or leaves, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a valid List of `Leaf` from `leaves`\n   *\n   * @param {List<Leaf>} leaves\n   * @return {List<Leaf>}\n   */\n\n  static createLeaves(leaves) {\n    if (leaves.size <= 1) return leaves\n\n    let invalid = false\n\n    // TODO: we can make this faster with [List] and then flatten\n    const result = List().withMutations(cache => {\n      // Search from the leaves left end to find invalid node;\n      leaves.findLast((leaf, index) => {\n        const firstLeaf = cache.first()\n\n        // If the first leaf of cache exist, check whether the first leaf is connectable with the current leaf\n        if (firstLeaf) {\n          // If marks equals, then the two leaves can be connected\n          if (firstLeaf.marks.equals(leaf.marks)) {\n            invalid = true\n            cache.set(0, firstLeaf.set('text', `${leaf.text}${firstLeaf.text}`))\n            return\n          }\n\n          // If the cached leaf is empty, drop the empty leaf with the upcoming leaf\n          if (firstLeaf.text === '') {\n            invalid = true\n            cache.set(0, leaf)\n            return\n          }\n\n          // If the current leaf is empty, drop the leaf\n          if (leaf.text === '') {\n            invalid = true\n            return\n          }\n        }\n\n        cache.unshift(leaf)\n      })\n    })\n\n    if (!invalid) return leaves\n    return result\n  }\n\n  /**\n   * Split a list of leaves to two lists; if the leaves are valid leaves, the returned leaves are also valid\n   * Corner Cases:\n   *   1. if offset is smaller than 0, then return [List(), leaves]\n   *   2. if offset is bigger than the text length, then return [leaves, List()]\n   *\n   * @param {List<Leaf> leaves\n   * @return {Array<List<Leaf>>}\n   */\n\n  static splitLeaves(leaves, offset) {\n    if (offset < 0) return [List(), leaves]\n\n    if (leaves.size === 0) {\n      return [List(), List()]\n    }\n\n    let endOffset = 0\n    let index = -1\n    let left, right\n\n    leaves.find(leaf => {\n      index++\n      const startOffset = endOffset\n      const { text } = leaf\n      endOffset += text.length\n\n      if (endOffset < offset) return false\n      if (startOffset > offset) return false\n\n      const length = offset - startOffset\n      left = leaf.set('text', text.slice(0, length))\n      right = leaf.set('text', text.slice(length))\n      return true\n    })\n\n    if (!left) return [leaves, List()]\n\n    if (left.text === '') {\n      if (index === 0) {\n        return [List.of(left), leaves]\n      }\n\n      return [leaves.take(index), leaves.skip(index)]\n    }\n\n    if (right.text === '') {\n      if (index === leaves.size - 1) {\n        return [leaves, List.of(right)]\n      }\n\n      return [leaves.take(index + 1), leaves.skip(index + 1)]\n    }\n\n    return [\n      leaves.take(index).push(left),\n      leaves.skip(index + 1).unshift(right),\n    ]\n  }\n\n  /**\n   * Create a `Leaf` list from `attrs`.\n   *\n   * @param {Array<Leaf|Object>|List<Leaf|Object>} attrs\n   * @return {List<Leaf>}\n   */\n\n  static createList(attrs = []) {\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      const list = new List(attrs.map(Leaf.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Leaf.createList\\` only accepts arrays or lists, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Leaf` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Leaf}\n   */\n\n  static fromJSON(object) {\n    const { text = '', marks = [] } = object\n\n    const leaf = new Leaf({\n      text,\n      marks: Set(marks.map(Mark.fromJSON)),\n    })\n\n    return leaf\n  }\n\n  /**\n   * Check if `any` is a `Leaf`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isLeaf = isType.bind(null, 'LEAF')\n\n  /**\n   * Check if `any` is a list of leaves.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isLeafList(any) {\n    return List.isList(any) && any.every(item => Leaf.isLeaf(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'leaf'\n  }\n\n  /**\n   * Update a `mark` at leaf, replace with newMark\n   *\n   * @param {Mark} mark\n   * @param {Mark} newMark\n   * @returns {Leaf}\n   */\n\n  updateMark(mark, newMark) {\n    const { marks } = this\n    if (newMark.equals(mark)) return this\n    if (!marks.has(mark)) return this\n    const newMarks = marks.withMutations(collection => {\n      collection.remove(mark).add(newMark)\n    })\n    return this.set('marks', newMarks)\n  }\n\n  /**\n   * Add a `mark` to the leaf.\n   *\n   * @param {Mark} mark\n   * @returns {Text}\n   */\n\n  addMark(mark) {\n    const { marks } = this\n    return this.set('marks', marks.add(mark))\n  }\n\n  /**\n   * Add a `set` of marks to the leaf.\n   *\n   * @param {Set<Mark>} set\n   * @returns {Text}\n   */\n\n  addMarks(set) {\n    const { marks } = this\n    return this.set('marks', marks.union(set))\n  }\n\n  /**\n   * Remove a `mark` from the leaf.\n   *\n   * @param {Mark} mark\n   * @returns {Text}\n   */\n\n  removeMark(mark) {\n    const { marks } = this\n    return this.set('marks', marks.remove(mark))\n  }\n\n  /**\n   * Return a JSON representation of the leaf.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      text: this.text,\n      marks: this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    return object\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nLeaf.prototype[MODEL_TYPES.LEAF] = true\n\n/**\n * Export.\n *\n * @type {Leaf}\n */\n\nexport default Leaf\n","/**\n * GLOBAL: True if memoization should is enabled.\n *\n * @type {Boolean}\n */\n\nlet ENABLED = true\n\n/**\n * GLOBAL: Changing this cache key will clear all previous cached results.\n *\n * @type {Number}\n */\n\nlet CACHE_KEY = 0\n\n/**\n * The leaf node of a cache tree. Used to support variable argument length. A\n * unique object, so that native Maps will key it by reference.\n *\n * @type {Object}\n */\n\nconst LEAF = {}\n\n/**\n * A value to represent a memoized undefined value. Allows efficient value\n * retrieval using Map.get only.\n *\n * @type {Object}\n */\n\nconst UNDEFINED = {}\n\n/**\n * Default value for unset keys in native Maps\n *\n * @type {Undefined}\n */\n\nconst UNSET = undefined\n\n/**\n * Memoize all of the `properties` on a `object`.\n *\n * @param {Object} object\n * @param {Array} properties\n * @return {Record}\n */\n\nfunction memoize(object, properties) {\n  for (const property of properties) {\n    const original = object[property]\n\n    if (!original) {\n      throw new Error(`Object does not have a property named \"${property}\".`)\n    }\n\n    object[property] = function(...args) {\n      // If memoization is disabled, call into the original method.\n      if (!ENABLED) return original.apply(this, args)\n\n      // If the cache key is different, previous caches must be cleared.\n      if (CACHE_KEY !== this.__cache_key) {\n        this.__cache_key = CACHE_KEY\n        this.__cache = new Map() // eslint-disable-line no-undef,no-restricted-globals\n        this.__cache_no_args = {}\n      }\n\n      if (!this.__cache) {\n        this.__cache = new Map() // eslint-disable-line no-undef,no-restricted-globals\n      }\n\n      if (!this.__cache_no_args) {\n        this.__cache_no_args = {}\n      }\n\n      const takesArguments = args.length !== 0\n\n      let cachedValue\n      let keys\n\n      if (takesArguments) {\n        keys = [property, ...args]\n        cachedValue = getIn(this.__cache, keys)\n      } else {\n        cachedValue = this.__cache_no_args[property]\n      }\n\n      // If we've got a result already, return it.\n      if (cachedValue !== UNSET) {\n        return cachedValue === UNDEFINED ? undefined : cachedValue\n      }\n\n      // Otherwise calculate what it should be once and cache it.\n      const value = original.apply(this, args)\n      const v = value === undefined ? UNDEFINED : value\n\n      if (takesArguments) {\n        this.__cache = setIn(this.__cache, keys, v)\n      } else {\n        this.__cache_no_args[property] = v\n      }\n\n      return value\n    }\n  }\n}\n\n/**\n * Get a value at a key path in a tree of Map.\n *\n * If not set, returns UNSET.\n * If the set value is undefined, returns UNDEFINED.\n *\n * @param {Map} map\n * @param {Array} keys\n * @return {Any|UNSET|UNDEFINED}\n */\n\nfunction getIn(map, keys) {\n  for (const key of keys) {\n    map = map.get(key)\n    if (map === UNSET) return UNSET\n  }\n\n  return map.get(LEAF)\n}\n\n/**\n * Set a value at a key path in a tree of Map, creating Maps on the go.\n *\n * @param {Map} map\n * @param {Array} keys\n * @param {Any} value\n * @return {Map}\n */\n\nfunction setIn(map, keys, value) {\n  let parent = map\n  let child\n\n  for (const key of keys) {\n    child = parent.get(key)\n\n    // If the path was not created yet...\n    if (child === UNSET) {\n      child = new Map() // eslint-disable-line no-undef,no-restricted-globals\n      parent.set(key, child)\n    }\n\n    parent = child\n  }\n\n  // The whole path has been created, so set the value to the bottom most map.\n  child.set(LEAF, value)\n  return map\n}\n\n/**\n * In DEV mode, clears the previously memoized values, globally.\n *\n * @return {Void}\n */\n\nfunction resetMemoization() {\n  CACHE_KEY++\n\n  if (CACHE_KEY >= Number.MAX_SAFE_INTEGER) {\n    CACHE_KEY = 0\n  }\n}\n\n/**\n * In DEV mode, enable or disable the use of memoize values, globally.\n *\n * @param {Boolean} enabled\n * @return {Void}\n */\n\nfunction useMemoization(enabled) {\n  ENABLED = enabled\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default memoize\nexport { resetMemoization, useMemoization }\n","import isPlainObject from 'is-plain-object'\nimport warning from 'slate-dev-warning'\nimport { List, OrderedSet, Record, Set } from 'immutable'\n\nimport Leaf from './leaf'\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport KeyUtils from '../utils/key-utils'\nimport memoize from '../utils/memoize'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  leaves: List(),\n  key: undefined,\n}\n\n/**\n * Text.\n *\n * @type {Text}\n */\n\nclass Text extends Record(DEFAULTS) {\n  /**\n   * Create a new `Text` with `attrs`.\n   *\n   * @param {Object|Array|List|String|Text} attrs\n   * @return {Text}\n   */\n\n  static create(attrs = '') {\n    if (Text.isText(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { leaves: [{ text: attrs }] }\n    }\n\n    if (isPlainObject(attrs)) {\n      if (attrs.text) {\n        const { text, marks, key } = attrs\n        attrs = { key, leaves: [{ text, marks }] }\n      }\n\n      return Text.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Text.create\\` only accepts objects, arrays, strings or texts, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Texts` from `elements`.\n   *\n   * @param {Array<Text|Object>|List<Text|Object>} elements\n   * @return {List<Text>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Text.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Text.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Text` from a JSON `object`.\n   *\n   * @param {Object|Text} object\n   * @return {Text}\n   */\n\n  static fromJSON(object) {\n    if (Text.isText(object)) {\n      return object\n    }\n\n    const { key = KeyUtils.create() } = object\n    let { leaves } = object\n\n    if (!leaves) {\n      if (object.ranges) {\n        warning(\n          false,\n          'As of slate@0.27.0, the `ranges` property of Slate objects has been renamed to `leaves`.'\n        )\n\n        leaves = object.ranges\n      } else {\n        leaves = List()\n      }\n    }\n\n    if (Array.isArray(leaves)) {\n      leaves = List(leaves.map(x => Leaf.create(x)))\n    } else if (List.isList(leaves)) {\n      leaves = leaves.map(x => Leaf.create(x))\n    } else {\n      throw new Error('leaves must be either Array or Immutable.List')\n    }\n\n    const node = new Text({\n      leaves: Leaf.createLeaves(leaves),\n      key,\n    })\n\n    return node\n  }\n\n  /**\n   * Check if `any` is a `Text`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isText = isType.bind(null, 'TEXT')\n\n  /**\n   * Check if `any` is a list of texts.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isTextList(any) {\n    return List.isList(any) && any.every(item => Text.isText(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'text'\n  }\n\n  /**\n   * Find the 'first' leaf at offset; By 'first' the alorighthm prefers `endOffset === offset` than `startOffset === offset`\n   * Corner Cases:\n   *   1. if offset is negative, return the first leaf;\n   *   2. if offset is larger than text length, the leaf is null, startOffset, endOffset and index is of the last leaf\n   *\n   * @param {number}\n   * @returns {Object}\n   *   @property {number} startOffset\n   *   @property {number} endOffset\n   *   @property {number} index\n   *   @property {Leaf} leaf\n   */\n\n  searchLeafAtOffset(offset) {\n    let endOffset = 0\n    let startOffset = 0\n    let index = -1\n\n    const leaf = this.leaves.find(l => {\n      index++\n      startOffset = endOffset\n      endOffset = startOffset + l.text.length\n      return endOffset >= offset\n    })\n\n    return {\n      leaf,\n      endOffset,\n      index,\n      startOffset,\n    }\n  }\n\n  /**\n   * Add a `mark` at `index` and `length`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Text}\n   */\n\n  addMark(index, length, mark) {\n    const marks = Set.of(mark)\n    return this.addMarks(index, length, marks)\n  }\n\n  /**\n   * Add a `set` of marks at `index` and `length`.\n   * Corner Cases:\n   *   1. If empty text, and if length === 0 and index === 0, will make sure the text contain an empty leaf with the given mark.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Set<Mark>} set\n   * @return {Text}\n   */\n\n  addMarks(index, length, set) {\n    if (this.text === '' && length === 0 && index === 0) {\n      const { leaves } = this\n      const first = leaves.first()\n\n      if (!first) {\n        return this.set(\n          'leaves',\n          List.of(Leaf.fromJSON({ text: '', marks: set }))\n        )\n      }\n\n      const newFirst = first.addMarks(set)\n      if (newFirst === first) return this\n      return this.set('leaves', List.of(newFirst))\n    }\n\n    if (this.text === '') return this\n    if (length === 0) return this\n    if (index >= this.text.length) return this\n\n    const [before, bundle] = Leaf.splitLeaves(this.leaves, index)\n    const [middle, after] = Leaf.splitLeaves(bundle, length)\n    const leaves = before.concat(middle.map(x => x.addMarks(set)), after)\n    return this.setLeaves(leaves)\n  }\n\n  /**\n   * Derive the leaves for a list of `decorations`.\n   *\n   * @param {Array|Void} decorations (optional)\n   * @return {List<Leaf>}\n   */\n\n  getLeaves(decorations = []) {\n    let { leaves } = this\n    if (leaves.size === 0) return List.of(Leaf.create({}))\n    if (!decorations || decorations.length === 0) return leaves\n    if (this.text.length === 0) return leaves\n    const { key } = this\n\n    decorations.forEach(dec => {\n      const { start, end, mark } = dec\n      const hasStart = start.key == key\n      const hasEnd = end.key == key\n\n      if (hasStart && hasEnd) {\n        const index = hasStart ? start.offset : 0\n        const length = hasEnd ? end.offset - index : this.text.length - index\n\n        if (length < 1) return\n        if (index >= this.text.length) return\n\n        if (index !== 0 || length < this.text.length) {\n          const [before, bundle] = Leaf.splitLeaves(leaves, index)\n          const [middle, after] = Leaf.splitLeaves(bundle, length)\n          leaves = before.concat(middle.map(x => x.addMark(mark)), after)\n          return\n        }\n      }\n\n      leaves = leaves.map(x => x.addMark(mark))\n    })\n\n    if (leaves === this.leaves) return leaves\n    return Leaf.createLeaves(leaves)\n  }\n\n  /**\n   * Get all of the active marks on between two offsets\n   * Corner Cases:\n   *   1. if startOffset is equal or bigger than endOffset, then return Set();\n   *   2. If no text is selected between start and end, then return Set()\n   *\n   * @return {Set<Mark>}\n   */\n\n  getActiveMarksBetweenOffsets(startOffset, endOffset) {\n    if (startOffset <= 0 && endOffset >= this.text.length) {\n      return this.getActiveMarks()\n    }\n\n    if (startOffset >= endOffset) return Set()\n    // For empty text in a paragraph, use getActiveMarks;\n    if (this.text === '') return this.getActiveMarks()\n\n    let result = null\n    let leafEnd = 0\n\n    this.leaves.forEach(leaf => {\n      const leafStart = leafEnd\n      leafEnd = leafStart + leaf.text.length\n\n      if (leafEnd <= startOffset) return\n      if (leafStart >= endOffset) return false\n\n      if (!result) {\n        result = leaf.marks\n        return\n      }\n\n      result = result.intersect(leaf.marks)\n      if (result && result.size === 0) return false\n      return false\n    })\n\n    return result || Set()\n  }\n\n  /**\n   * Get all of the active marks on the text\n   *\n   * @return {Set<Mark>}\n   */\n\n  getActiveMarks() {\n    if (this.leaves.size === 0) return Set()\n\n    const result = this.leaves.first().marks\n    if (result.size === 0) return result\n\n    return result.withMutations(x => {\n      this.leaves.forEach(c => {\n        x.intersect(c.marks)\n        if (x.size === 0) return false\n      })\n    })\n  }\n\n  /**\n   * Get all of the marks on between two offsets\n   * Corner Cases:\n   *   1. if startOffset is equal or bigger than endOffset, then return Set();\n   *   2. If no text is selected between start and end, then return Set()\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getMarksBetweenOffsets(startOffset, endOffset) {\n    if (startOffset <= 0 && endOffset >= this.text.length) {\n      return this.getMarks()\n    }\n\n    if (startOffset >= endOffset) return Set()\n    // For empty text in a paragraph, use getActiveMarks;\n    if (this.text === '') return this.getActiveMarks()\n\n    let result = null\n    let leafEnd = 0\n\n    this.leaves.forEach(leaf => {\n      const leafStart = leafEnd\n      leafEnd = leafStart + leaf.text.length\n\n      if (leafEnd <= startOffset) return\n      if (leafStart >= endOffset) return false\n\n      if (!result) {\n        result = leaf.marks\n        return\n      }\n\n      result = result.union(leaf.marks)\n    })\n\n    return result || Set()\n  }\n\n  /**\n   * Get all of the marks on the text.\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getMarks() {\n    const array = this.getMarksAsArray()\n    return new OrderedSet(array)\n  }\n\n  /**\n   * Get all of the marks on the text as an array\n   *\n   * @return {Array}\n   */\n\n  getMarksAsArray() {\n    if (this.leaves.size === 0) return []\n    const first = this.leaves.first().marks\n    if (this.leaves.size === 1) return first.toArray()\n\n    const result = []\n\n    this.leaves.forEach(leaf => {\n      result.push(leaf.marks.toArray())\n    })\n\n    return Array.prototype.concat.apply(first.toArray(), result)\n  }\n\n  /**\n   * Get the marks on the text at `index`.\n   * Corner Cases:\n   *   1. if no text is before the index, and index !== 0, then return Set()\n   *   2. (for insert after split node or mark at range) if index === 0, and text === '', then return the leaf.marks\n   *   3. if index === 0, text !== '', return Set()\n   *\n   *\n   * @param {Number} index\n   * @return {Set<Mark>}\n   */\n\n  getMarksAtIndex(index) {\n    const { leaf } = this.searchLeafAtOffset(index)\n    if (!leaf) return Set()\n    return leaf.marks\n  }\n\n  /**\n   * Insert `text` at `index`.\n   *\n   * @param {Numbder} offset\n   * @param {String} text\n   * @param {Set} marks (optional)\n   * @return {Text}\n   */\n\n  insertText(offset, text, marks) {\n    if (this.text === '') {\n      return this.set('leaves', List.of(Leaf.create({ text, marks })))\n    }\n\n    if (text.length === 0) return this\n    if (!marks) marks = Set()\n\n    const { startOffset, leaf, index } = this.searchLeafAtOffset(offset)\n    const delta = offset - startOffset\n    const beforeText = leaf.text.slice(0, delta)\n    const afterText = leaf.text.slice(delta)\n    const { leaves } = this\n\n    if (leaf.marks.equals(marks)) {\n      return this.set(\n        'leaves',\n        leaves.set(index, leaf.set('text', beforeText + text + afterText))\n      )\n    }\n\n    const nextLeaves = leaves.splice(\n      index,\n      1,\n      leaf.set('text', beforeText),\n      Leaf.create({ text, marks }),\n      leaf.set('text', afterText)\n    )\n\n    return this.setLeaves(nextLeaves)\n  }\n\n  /**\n   * Remove a `mark` at `index` and `length`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Text}\n   */\n\n  removeMark(index, length, mark) {\n    if (this.text === '' && index === 0 && length === 0) {\n      const first = this.leaves.first()\n      if (!first) return this\n      const newFirst = first.removeMark(mark)\n      if (newFirst === first) return this\n      return this.set('leaves', List.of(newFirst))\n    }\n\n    if (length <= 0) return this\n    if (index >= this.text.length) return this\n    const [before, bundle] = Leaf.splitLeaves(this.leaves, index)\n    const [middle, after] = Leaf.splitLeaves(bundle, length)\n    const leaves = before.concat(middle.map(x => x.removeMark(mark)), after)\n    return this.setLeaves(leaves)\n  }\n\n  /**\n   * Remove text from the text node at `start` for `length`.\n   *\n   * @param {Number} start\n   * @param {Number} length\n   * @return {Text}\n   */\n\n  removeText(start, length) {\n    if (length <= 0) return this\n    if (start >= this.text.length) return this\n\n    // PERF: For simple backspace, we can operate directly on the leaf\n    if (length === 1) {\n      const { leaf, index, startOffset } = this.searchLeafAtOffset(start + 1)\n      const offset = start - startOffset\n\n      if (leaf) {\n        if (leaf.text.length === 1) {\n          const leaves = this.leaves.remove(index)\n          return this.setLeaves(leaves)\n        }\n\n        const beforeText = leaf.text.slice(0, offset)\n        const afterText = leaf.text.slice(offset + length)\n        const text = beforeText + afterText\n\n        if (text.length > 0) {\n          return this.set(\n            'leaves',\n            this.leaves.set(index, leaf.set('text', text))\n          )\n        }\n      }\n    }\n\n    const [before, bundle] = Leaf.splitLeaves(this.leaves, start)\n    const after = Leaf.splitLeaves(bundle, length)[1]\n    const leaves = Leaf.createLeaves(before.concat(after))\n\n    if (leaves.size === 1) {\n      const first = leaves.first()\n\n      if (first.text === '') {\n        return this.set(\n          'leaves',\n          List.of(first.set('marks', this.getActiveMarks()))\n        )\n      }\n    }\n\n    return this.set('leaves', leaves)\n  }\n\n  /**\n   * Return a JSON representation of the text.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      leaves: this.getLeaves()\n        .toArray()\n        .map(r => r.toJSON()),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n\n  /**\n   * Update a `mark` at `index` and `length` with `properties`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Mark} mark\n   * @param {Object} properties\n   * @return {Text}\n   */\n\n  updateMark(index, length, mark, properties) {\n    const newMark = mark.merge(properties)\n\n    if (this.text === '' && length === 0 && index === 0) {\n      const { leaves } = this\n      const first = leaves.first()\n      if (!first) return this\n      const newFirst = first.updateMark(mark, newMark)\n      if (newFirst === first) return this\n      return this.set('leaves', List.of(newFirst))\n    }\n\n    if (length <= 0) return this\n    if (index >= this.text.length) return this\n\n    const [before, bundle] = Leaf.splitLeaves(this.leaves, index)\n    const [middle, after] = Leaf.splitLeaves(bundle, length)\n\n    const leaves = before.concat(\n      middle.map(x => x.updateMark(mark, newMark)),\n      after\n    )\n\n    return this.setLeaves(leaves)\n  }\n\n  /**\n   * Split this text and return two different texts\n   * @param {Number} position\n   * @returns {Array<Text>}\n   */\n\n  splitText(offset) {\n    const splitted = Leaf.splitLeaves(this.leaves, offset)\n    const one = this.set('leaves', splitted[0])\n    const two = this.set('leaves', splitted[1]).regenerateKey()\n    return [one, two]\n  }\n\n  /**\n   * merge this text and another text at the end\n   * @param {Text} text\n   * @returns {Text}\n   */\n\n  mergeText(text) {\n    const leaves = this.leaves.concat(text.leaves)\n    return this.setLeaves(leaves)\n  }\n\n  /**\n   * Set leaves with normalized `leaves`\n   *\n   * @param {Schema} schema\n   * @returns {Text|Null}\n   */\n\n  setLeaves(leaves) {\n    const result = Leaf.createLeaves(leaves)\n\n    if (result.size === 1) {\n      const first = result.first()\n\n      if (!first.marks || first.marks.size === 0) {\n        if (first.text === '') {\n          return this.set('leaves', List())\n        }\n      }\n    }\n\n    return this.set('leaves', Leaf.createLeaves(leaves))\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nText.prototype[MODEL_TYPES.TEXT] = true\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Text.prototype, ['getActiveMarks', 'getMarks', 'getMarksAsArray'])\n\n/**\n * Export.\n *\n * @type {Text}\n */\n\nexport default Text\n","import isPlainObject from 'is-plain-object'\nimport warning from 'slate-dev-warning'\nimport { List } from 'immutable'\n\nimport Block from './block'\nimport Data from './data'\nimport Document from './document'\nimport Inline from './inline'\nimport Text from './text'\nimport { isType } from '../constants/model-types'\n\n/**\n * A pseudo-model that is used for its static methods only.\n *\n * @type {Node}\n */\n\nclass Node {\n  /**\n   * Create a new `Node` with `attrs`.\n   *\n   * @param {Object|Node} attrs\n   * @return {Node}\n   */\n\n  static create(attrs = {}) {\n    if (Node.isNode(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      let { object } = attrs\n\n      if (!object && attrs.kind) {\n        warning(\n          false,\n          'As of slate@0.32.0, the `kind` property of Slate objects has been renamed to `object`.'\n        )\n\n        object = attrs.kind\n      }\n\n      switch (object) {\n        case 'block':\n          return Block.create(attrs)\n        case 'document':\n          return Document.create(attrs)\n        case 'inline':\n          return Inline.create(attrs)\n        case 'text':\n          return Text.create(attrs)\n\n        default: {\n          throw new Error('`Node.create` requires a `object` string.')\n        }\n      }\n    }\n\n    throw new Error(\n      `\\`Node.create\\` only accepts objects or nodes but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Nodes` from an array.\n   *\n   * @param {Array<Object|Node>} elements\n   * @return {List<Node>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = List(elements.map(Node.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Node.createList\\` only accepts lists or arrays, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable node properties from `attrs`.\n   *\n   * @param {Object|String|Node} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Block.isBlock(attrs) || Inline.isInline(attrs)) {\n      return {\n        data: attrs.data,\n        type: attrs.type,\n      }\n    }\n\n    if (typeof attrs == 'string') {\n      return { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('type' in attrs) props.type = attrs.type\n      if ('data' in attrs) props.data = Data.create(attrs.data)\n      return props\n    }\n\n    throw new Error(\n      `\\`Node.createProperties\\` only accepts objects, strings, blocks or inlines, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Node` from a JSON `value`.\n   *\n   * @param {Object} value\n   * @return {Node}\n   */\n\n  static fromJSON(value) {\n    let { object } = value\n\n    if (!object && value.kind) {\n      warning(\n        false,\n        'As of slate@0.32.0, the `kind` property of Slate objects has been renamed to `object`.'\n      )\n\n      object = value.kind\n    }\n\n    switch (object) {\n      case 'block':\n        return Block.fromJSON(value)\n      case 'document':\n        return Document.fromJSON(value)\n      case 'inline':\n        return Inline.fromJSON(value)\n      case 'text':\n        return Text.fromJSON(value)\n\n      default: {\n        throw new Error(\n          `\\`Node.fromJSON\\` requires an \\`object\\` of either 'block', 'document', 'inline' or 'text', but you passed: ${value}`\n        )\n      }\n    }\n  }\n\n  /**\n   * Check if `any` is a `Node`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isNode(any) {\n    return !!['BLOCK', 'DOCUMENT', 'INLINE', 'TEXT'].find(type =>\n      isType(type, any)\n    )\n  }\n\n  /**\n   * Check if `any` is a list of nodes.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isNodeList(any) {\n    return List.isList(any) && any.every(item => Node.isNode(item))\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Node\n","import isPlainObject from 'is-plain-object'\nimport { List, Map, Record } from 'immutable'\n\nimport KeyUtils from '../utils/key-utils'\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport Node from './node'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  key: undefined,\n  nodes: new List(),\n  type: undefined,\n}\n\n/**\n * Block.\n *\n * @type {Block}\n */\n\nclass Block extends Record(DEFAULTS) {\n  /**\n   * Create a new `Block` from `attrs`.\n   *\n   * @param {Object|String|Block} attrs\n   * @return {Block}\n   */\n\n  static create(attrs = {}) {\n    if (Block.isBlock(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Block.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Block.create\\` only accepts objects, strings or blocks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Blocks` from `attrs`.\n   *\n   * @param {Array<Block|Object>|List<Block|Object>} attrs\n   * @return {List<Block>}\n   */\n\n  static createList(attrs = []) {\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      const list = new List(attrs.map(Block.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Block.createList\\` only accepts arrays or lists, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Block` from a JSON `object`.\n   *\n   * @param {Object|Block} object\n   * @return {Block}\n   */\n\n  static fromJSON(object) {\n    if (Block.isBlock(object)) {\n      return object\n    }\n\n    const { data = {}, key = KeyUtils.create(), nodes = [], type } = object\n\n    if (typeof type != 'string') {\n      throw new Error('`Block.fromJSON` requires a `type` string.')\n    }\n\n    const block = new Block({\n      key,\n      type,\n      data: Map(data),\n      nodes: Node.createList(nodes),\n    })\n\n    return block\n  }\n\n  /**\n   * Check if `any` is a `Block`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isBlock = isType.bind(null, 'BLOCK')\n\n  /**\n   * Check if `any` is a block list.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isBlockList(any) {\n    return List.isList(any) && any.every(item => Block.isBlock(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'block'\n  }\n\n  /**\n   * Return a JSON representation of the block.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      type: this.type,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nBlock.prototype[MODEL_TYPES.BLOCK] = true\n\n/**\n * Export.\n *\n * @type {Block}\n */\n\nexport default Block\n","import Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Mix in the changes that pass through to their at-range equivalents because\n * they don't have any effect on the selection.\n */\n\nconst PROXY_TRANSFORMS = [\n  'deleteBackward',\n  'deleteCharBackward',\n  'deleteLineBackward',\n  'deleteWordBackward',\n  'deleteForward',\n  'deleteCharForward',\n  'deleteWordForward',\n  'deleteLineForward',\n  'setBlocks',\n  'setInlines',\n  'splitInline',\n  'unwrapBlock',\n  'unwrapInline',\n  'wrapBlock',\n  'wrapInline',\n]\n\nPROXY_TRANSFORMS.forEach(method => {\n  Changes[method] = (change, ...args) => {\n    const { value } = change\n    const { selection } = value\n    const methodAtRange = `${method}AtRange`\n    change[methodAtRange](selection, ...args)\n\n    if (method.match(/Backward$/)) {\n      change.moveToStart()\n    } else if (method.match(/Forward$/)) {\n      change.moveToEnd()\n    }\n  }\n})\n\n/**\n * Add a `mark` to the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.addMark = (change, mark) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const { document, selection } = value\n\n  if (selection.isExpanded) {\n    change.addMarkAtRange(selection, mark)\n  } else if (selection.marks) {\n    const marks = selection.marks.add(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  } else {\n    const marks = document.getActiveMarksAtRange(selection).add(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  }\n}\n\n/**\n * Add a list of `marks` to the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.addMarks = (change, marks) => {\n  marks.forEach(mark => change.addMark(mark))\n}\n\n/**\n * Delete at the current selection.\n *\n * @param {Change} change\n */\n\nChanges.delete = change => {\n  const { value } = change\n  const { selection } = value\n  change.deleteAtRange(selection)\n\n  // Ensure that the selection is collapsed to the start, because in certain\n  // cases when deleting across inline nodes, when splitting the inline node the\n  // end point of the selection will end up after the split point.\n  change.moveToStart()\n}\n\n/**\n * Insert a `block` at the current selection.\n *\n * @param {Change} change\n * @param {String|Object|Block} block\n */\n\nChanges.insertBlock = (change, block) => {\n  block = Block.create(block)\n  const { value } = change\n  const { selection } = value\n  change.insertBlockAtRange(selection, block)\n\n  // If the node was successfully inserted, update the selection.\n  const node = change.value.document.getNode(block.key)\n  if (node) change.moveToEndOfNode(node)\n}\n\n/**\n * Insert a `fragment` at the current selection.\n *\n * @param {Change} change\n * @param {Document} fragment\n */\n\nChanges.insertFragment = (change, fragment) => {\n  if (!fragment.nodes.size) return\n\n  let { value } = change\n  let { document, selection } = value\n  const { start, end } = selection\n  const { startText, endText, startInline } = value\n  const lastText = fragment.getLastText()\n  const lastInline = fragment.getClosestInline(lastText.key)\n  const firstChild = fragment.nodes.first()\n  const lastChild = fragment.nodes.last()\n  const keys = document.getTexts().map(text => text.key)\n  const isAppending =\n    !startInline ||\n    (start.isAtStartOfNode(startText) || end.isAtStartOfNode(startText)) ||\n    (start.isAtEndOfNode(endText) || end.isAtEndOfNode(endText))\n\n  const isInserting =\n    firstChild.hasBlockChildren() || lastChild.hasBlockChildren()\n\n  change.insertFragmentAtRange(selection, fragment)\n  value = change.value\n  document = value.document\n\n  const newTexts = document.getTexts().filter(n => !keys.includes(n.key))\n  const newText = isAppending ? newTexts.last() : newTexts.takeLast(2).first()\n\n  if (newText && (lastInline || isInserting)) {\n    change.select(selection.moveToEndOfNode(newText))\n  } else if (newText) {\n    change.select(\n      selection.moveToStartOfNode(newText).moveForward(lastText.text.length)\n    )\n  } else {\n    change.select(selection.moveToStart().moveForward(lastText.text.length))\n  }\n}\n\n/**\n * Insert an `inline` at the current selection.\n *\n * @param {Change} change\n * @param {String|Object|Inline} inline\n */\n\nChanges.insertInline = (change, inline) => {\n  inline = Inline.create(inline)\n  const { value } = change\n  const { selection } = value\n  change.insertInlineAtRange(selection, inline)\n\n  // If the node was successfully inserted, update the selection.\n  const node = change.value.document.getNode(inline.key)\n  if (node) change.moveToEndOfNode(node)\n}\n\n/**\n * Insert a string of `text` with optional `marks` at the current selection.\n *\n * @param {Change} change\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nChanges.insertText = (change, text, marks) => {\n  const { value } = change\n  const { document, selection } = value\n  marks = marks || selection.marks || document.getInsertMarksAtRange(selection)\n  change.insertTextAtRange(selection, text, marks)\n\n  // If the text was successfully inserted, and the selection had marks on it,\n  // unset the selection's marks.\n  if (selection.marks && document != change.value.document) {\n    change.select({ marks: null })\n  }\n}\n\n/**\n * Remove a `mark` from the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.removeMark = (change, mark) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const { document, selection } = value\n\n  if (selection.isExpanded) {\n    change.removeMarkAtRange(selection, mark)\n  } else if (selection.marks) {\n    const marks = selection.marks.remove(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  } else {\n    const marks = document.getActiveMarksAtRange(selection).remove(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  }\n}\n\n/**\n * Replace an `oldMark` with a `newMark` in the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} oldMark\n * @param {Mark} newMark\n */\n\nChanges.replaceMark = (change, oldMark, newMark) => {\n  change.removeMark(oldMark)\n  change.addMark(newMark)\n}\n\n/**\n * Split the block node at the current selection, to optional `depth`.\n *\n * @param {Change} change\n * @param {Number} depth (optional)\n */\n\nChanges.splitBlock = (change, depth = 1) => {\n  const { value } = change\n  const { selection, document } = value\n  const marks = selection.marks || document.getInsertMarksAtRange(selection)\n  change.splitBlockAtRange(selection, depth).moveToEnd()\n\n  if (marks && marks.size !== 0) {\n    change.select({ marks })\n  }\n}\n\n/**\n * Add or remove a `mark` from the characters in the current selection,\n * depending on whether it's already there.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.toggleMark = (change, mark) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const exists = value.activeMarks.has(mark)\n\n  if (exists) {\n    change.removeMark(mark)\n  } else {\n    change.addMark(mark)\n  }\n}\n\n/**\n * Wrap the current selection with prefix/suffix.\n *\n * @param {Change} change\n * @param {String} prefix\n * @param {String} suffix\n */\n\nChanges.wrapText = (change, prefix, suffix = prefix) => {\n  const { value } = change\n  const { selection } = value\n  change.wrapTextAtRange(selection, prefix, suffix)\n\n  // If the selection was collapsed, it will have moved the start offset too.\n  if (selection.isCollapsed) {\n    change.moveStartBackward(prefix.length)\n  }\n\n  // Adding the suffix will have pushed the end of the selection further on, so\n  // we need to move it back to account for this.\n  change.moveEndBackward(suffix.length)\n\n  // There's a chance that the selection points moved \"through\" each other,\n  // resulting in a now-incorrect selection direction.\n  if (selection.isForward != change.value.selection.isForward) {\n    change.flip()\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import { reverse } from 'esrever'\n\n/**\n * Surrogate pair start and end points.\n *\n * @type {Number}\n */\n\nconst SURROGATE_START = 0xd800\nconst SURROGATE_END = 0xdfff\n\n/**\n * A regex to match space characters.\n *\n * @type {RegExp}\n */\n\nconst SPACE = /\\s/\n\n/**\n * A regex to match chameleon characters, that count as word characters as long\n * as they are inside of a word.\n *\n * @type {RegExp}\n */\n\nconst CHAMELEON = /['\\u2018\\u2019]/\n\n/**\n * A regex that matches punctuation.\n *\n * @type {RegExp}\n */\n\nconst PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n\n/**\n * Is a character `code` in a surrogate character.\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isSurrogate(code) {\n  return SURROGATE_START <= code && code <= SURROGATE_END\n}\n\n/**\n * Is a character a word character? Needs the `remaining` characters too.\n *\n * @param {String} char\n * @param {String|Void} remaining\n * @return {Boolean}\n */\n\nfunction isWord(char, remaining) {\n  if (SPACE.test(char)) return false\n\n  // If it's a chameleon character, recurse to see if the next one is or not.\n  if (CHAMELEON.test(char)) {\n    let next = remaining.charAt(0)\n    const length = getCharLength(next)\n    next = remaining.slice(0, length)\n    const rest = remaining.slice(length)\n    if (isWord(next, rest)) return true\n  }\n\n  if (PUNCTUATION.test(char)) return false\n  return true\n}\n\n/**\n * Get the length of a `character`.\n *\n * @param {String} char\n * @return {Number}\n */\n\nfunction getCharLength(char) {\n  return isSurrogate(char.charCodeAt(0)) ? 2 : 1\n}\n\n/**\n * Get the offset to the end of the first character in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getCharOffset(text) {\n  const char = text.charAt(0)\n  return getCharLength(char)\n}\n\n/**\n * Get the offset to the end of the character before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetBackward(text, offset) {\n  text = text.slice(0, offset)\n  text = reverse(text)\n  return getCharOffset(text)\n}\n\n/**\n * Get the offset to the end of the character after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetForward(text, offset) {\n  text = text.slice(offset)\n  return getCharOffset(text)\n}\n\n/**\n * Get the offset to the end of the first word in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getWordOffset(text) {\n  let length = 0\n  let i = 0\n  let started = false\n  let char\n\n  while ((char = text.charAt(i))) {\n    const l = getCharLength(char)\n    char = text.slice(i, i + l)\n    const rest = text.slice(i + l)\n\n    if (isWord(char, rest)) {\n      started = true\n      length += l\n    } else if (!started) {\n      length += l\n    } else {\n      break\n    }\n\n    i += l\n  }\n\n  return length\n}\n\n/**\n * Get the offset to the end of the word before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetBackward(text, offset) {\n  text = text.slice(0, offset)\n  text = reverse(text)\n  const o = getWordOffset(text)\n  return o\n}\n\n/**\n * Get the offset to the end of the word after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetForward(text, offset) {\n  text = text.slice(offset)\n  const o = getWordOffset(text)\n  return o\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  getCharLength,\n  getCharOffset,\n  getCharOffsetBackward,\n  getCharOffsetForward,\n  getWordOffset,\n  getWordOffsetBackward,\n  getWordOffsetForward,\n  isSurrogate,\n  isWord,\n}\n","import { List } from 'immutable'\nimport Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport TextUtils from '../utils/text-utils'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Add a new `mark` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.addMarkAtRange = (change, range, mark, options = {}) => {\n  if (range.isCollapsed) return\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const { start, end } = range\n  const texts = document.getTextsAtRange(range)\n\n  texts.forEach(node => {\n    const { key } = node\n    let index = 0\n    let length = node.text.length\n\n    if (key == start.key) index = start.offset\n    if (key == end.key) length = end.offset\n    if (key == start.key && key == end.key) length = end.offset - start.offset\n\n    change.addMarkByKey(key, index, length, mark, { normalize })\n  })\n}\n\n/**\n * Add a list of `marks` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Array<Mixed>} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.addMarksAtRange = (change, range, marks, options = {}) => {\n  marks.forEach(mark => change.addMarkAtRange(range, mark, options))\n}\n\n/**\n * Delete everything in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteAtRange = (change, range, options = {}) => {\n  // Snapshot the selection, which creates an extra undo save point, so that\n  // when you undo a delete, the expanded selection will be retained.\n  change.snapshotSelection()\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { start, end } = range\n  let startKey = start.key\n  let startOffset = start.offset\n  let endKey = end.key\n  let endOffset = end.offset\n  let { document, schema } = value\n  let isStartVoid = document.hasVoidParent(startKey, schema)\n  let isEndVoid = document.hasVoidParent(endKey, schema)\n  let startBlock = document.getClosestBlock(startKey, schema)\n  let endBlock = document.getClosestBlock(endKey, schema)\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  const isHanging =\n    startOffset == 0 &&\n    endOffset == 0 &&\n    isStartVoid == false &&\n    startKey == startBlock.getFirstText().key &&\n    endKey == endBlock.getFirstText().key\n\n  // If it's a hanging selection, nudge it back to end in the previous text.\n  if (isHanging && isEndVoid) {\n    const prevText = document.getPreviousText(endKey)\n    endKey = prevText.key\n    endOffset = prevText.text.length\n    isEndVoid = document.hasVoidParent(endKey, schema)\n  }\n\n  // If the start node is inside a void node, remove the void node and update\n  // the starting point to be right after it, continuously until the start point\n  // is not a void, or until the entire range is handled.\n  while (isStartVoid) {\n    const startVoid = document.getClosestVoid(startKey, schema)\n    const nextText = document.getNextText(startKey)\n    change.removeNodeByKey(startVoid.key, { normalize: false })\n\n    // If the start and end keys are the same, we're done.\n    if (startKey == endKey) return\n\n    // If there is no next text node, we're done.\n    if (!nextText) return\n\n    // Continue...\n    document = change.value.document\n    startKey = nextText.key\n    startOffset = 0\n    isStartVoid = document.hasVoidParent(startKey, schema)\n  }\n\n  // If the end node is inside a void node, do the same thing but backwards. But\n  // we don't need any aborting checks because if we've gotten this far there\n  // must be a non-void node that will exit the loop.\n  while (isEndVoid) {\n    const endVoid = document.getClosestVoid(endKey, schema)\n    const prevText = document.getPreviousText(endKey)\n    change.removeNodeByKey(endVoid.key, { normalize: false })\n\n    // Continue...\n    document = change.value.document\n    endKey = prevText.key\n    endOffset = prevText.text.length\n    isEndVoid = document.hasVoidParent(endKey, schema)\n  }\n\n  // If the start and end key are the same, and it was a hanging selection, we\n  // can just remove the entire block.\n  if (startKey == endKey && isHanging) {\n    change.removeNodeByKey(startBlock.key, { normalize })\n    return\n  } else if (startKey == endKey) {\n    // Otherwise, if it wasn't hanging, we're inside a single text node, so we can\n    // simply remove the text in the range.\n    const index = startOffset\n    const length = endOffset - startOffset\n    change.removeTextByKey(startKey, index, length, { normalize })\n    return\n  } else {\n    // Otherwise, we need to recursively remove text and nodes inside the start\n    // block after the start offset and inside the end block before the end\n    // offset. Then remove any blocks that are in between the start and end\n    // blocks. Then finally merge the start and end nodes.\n    startBlock = document.getClosestBlock(startKey)\n    endBlock = document.getClosestBlock(endKey)\n    const startText = document.getNode(startKey)\n    const endText = document.getNode(endKey)\n    const startLength = startText.text.length - startOffset\n    const endLength = endOffset\n\n    const ancestor = document.getCommonAncestor(startKey, endKey)\n    const startChild = ancestor.getFurthestAncestor(startKey)\n    const endChild = ancestor.getFurthestAncestor(endKey)\n\n    const startParent = document.getParent(startBlock.key)\n    const startParentIndex = startParent.nodes.indexOf(startBlock)\n    const endParentIndex = startParent.nodes.indexOf(endBlock)\n\n    let child\n\n    // Iterate through all of the nodes in the tree after the start text node\n    // but inside the end child, and remove them.\n    child = startText\n\n    while (child.key != startChild.key) {\n      const parent = document.getParent(child.key)\n      const index = parent.nodes.indexOf(child)\n      const afters = parent.nodes.slice(index + 1)\n\n      afters.reverse().forEach(node => {\n        change.removeNodeByKey(node.key, { normalize: false })\n      })\n\n      child = parent\n    }\n\n    // Remove all of the middle children.\n    const startChildIndex = ancestor.nodes.indexOf(startChild)\n    const endChildIndex = ancestor.nodes.indexOf(endChild)\n    const middles = ancestor.nodes.slice(startChildIndex + 1, endChildIndex)\n\n    middles.reverse().forEach(node => {\n      change.removeNodeByKey(node.key, { normalize: false })\n    })\n\n    // Remove the nodes before the end text node in the tree.\n    child = endText\n\n    while (child.key != endChild.key) {\n      const parent = document.getParent(child.key)\n      const index = parent.nodes.indexOf(child)\n      const befores = parent.nodes.slice(0, index)\n\n      befores.reverse().forEach(node => {\n        change.removeNodeByKey(node.key, { normalize: false })\n      })\n\n      child = parent\n    }\n\n    // Remove any overlapping text content from the leaf text nodes.\n    if (startLength != 0) {\n      change.removeTextByKey(startKey, startOffset, startLength, {\n        normalize: false,\n      })\n    }\n\n    if (endLength != 0) {\n      change.removeTextByKey(endKey, 0, endOffset, { normalize: false })\n    }\n\n    // If the start and end blocks aren't the same, move and merge the end block\n    // into the start block.\n    if (startBlock.key != endBlock.key) {\n      document = change.value.document\n      const lonely = document.getFurthestOnlyChildAncestor(endBlock.key)\n\n      // Move the end block to be right after the start block.\n      if (endParentIndex != startParentIndex + 1) {\n        change.moveNodeByKey(\n          endBlock.key,\n          startParent.key,\n          startParentIndex + 1,\n          { normalize: false }\n        )\n      }\n\n      // If the selection is hanging, just remove the start block, otherwise\n      // merge the end block into it.\n      if (isHanging) {\n        change.removeNodeByKey(startBlock.key, { normalize: false })\n      } else {\n        change.mergeNodeByKey(endBlock.key, { normalize: false })\n      }\n\n      // If nested empty blocks are left over above the end block, remove them.\n      if (lonely) {\n        change.removeNodeByKey(lonely.key, { normalize: false })\n      }\n    }\n\n    // If we should normalize, do it now after everything.\n    if (normalize) {\n      change.normalizeNodeByKey(ancestor.key)\n    }\n  }\n}\n\n/**\n * Delete backward until the character boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteCharBackwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.key)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  const { text } = startBlock\n  const n = TextUtils.getCharOffsetBackward(text, o)\n  change.deleteBackwardAtRange(range, n, options)\n}\n\n/**\n * Delete backward until the line boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteLineBackwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.key)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  change.deleteBackwardAtRange(range, o, options)\n}\n\n/**\n * Delete backward until the word boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteWordBackwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.key)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  const { text } = startBlock\n  const n = o === 0 ? 1 : TextUtils.getWordOffsetBackward(text, o)\n  change.deleteBackwardAtRange(range, n, options)\n}\n\n/**\n * Delete backward `n` characters at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} n (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteBackwardAtRange = (change, range, n = 1, options = {}) => {\n  if (n === 0) return\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document, schema } = value\n  const { start, focus } = range\n\n  // If the range is expanded, perform a regular delete instead.\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize })\n    return\n  }\n\n  const voidParent = document.getClosestVoid(start.key, schema)\n\n  // If there is a void parent, delete it.\n  if (voidParent) {\n    change.removeNodeByKey(voidParent.key, { normalize })\n    return\n  }\n\n  const block = document.getClosestBlock(start.key)\n\n  // If the closest is not void, but empty, remove it\n  if (\n    block &&\n    !schema.isVoid(block) &&\n    block.text === '' &&\n    document.nodes.size !== 1\n  ) {\n    change.removeNodeByKey(block.key, { normalize })\n    return\n  }\n\n  // If the range is at the start of the document, abort.\n  if (start.isAtStartOfNode(document)) {\n    return\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  const text = document.getDescendant(start.key)\n\n  if (start.isAtStartOfNode(text)) {\n    const prev = document.getPreviousText(text.key)\n    const prevBlock = document.getClosestBlock(prev.key)\n    const prevVoid = document.getClosestVoid(prev.key, schema)\n\n    // If the previous text node has a void parent, remove it.\n    if (prevVoid) {\n      change.removeNodeByKey(prevVoid.key, { normalize })\n      return\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n == 1 && prevBlock != block) {\n      range = range.moveAnchorTo(prev.key, prev.text.length)\n      change.deleteAtRange(range, { normalize })\n      return\n    }\n  }\n\n  // If the focus offset is farther than the number of characters to delete,\n  // just remove the characters backwards inside the current node.\n  if (n < focus.offset) {\n    range = range.moveFocusBackward(n)\n    change.deleteAtRange(range, { normalize })\n    return\n  }\n\n  // Otherwise, we need to see how many nodes backwards to go.\n  let node = text\n  let offset = 0\n  let traversed = focus.offset\n\n  while (n > traversed) {\n    node = document.getPreviousText(node.key)\n    const next = traversed + node.text.length\n\n    if (n <= next) {\n      offset = next - n\n      break\n    } else {\n      traversed = next\n    }\n  }\n\n  range = range.moveAnchorTo(node.key, offset)\n  change.deleteAtRange(range, { normalize })\n}\n\n/**\n * Delete forward until the character boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteCharForwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.key)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  const { text } = startBlock\n  const n = TextUtils.getCharOffsetForward(text, o)\n  change.deleteForwardAtRange(range, n, options)\n}\n\n/**\n * Delete forward until the line boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteLineForwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.key)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  change.deleteForwardAtRange(range, startBlock.text.length - o, options)\n}\n\n/**\n * Delete forward until the word boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteWordForwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.key)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  const { text } = startBlock\n  const n = TextUtils.getWordOffsetForward(text, o)\n  change.deleteForwardAtRange(range, n, options)\n}\n\n/**\n * Delete forward `n` characters at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} n (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteForwardAtRange = (change, range, n = 1, options = {}) => {\n  if (n === 0) return\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document, schema } = value\n  const { start, focus } = range\n\n  // If the range is expanded, perform a regular delete instead.\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize })\n    return\n  }\n\n  const voidParent = document.getClosestVoid(start.key, schema)\n\n  // If the node has a void parent, delete it.\n  if (voidParent) {\n    change.removeNodeByKey(voidParent.key, { normalize })\n    return\n  }\n\n  const block = document.getClosestBlock(start.key)\n\n  // If the closest is not void, but empty, remove it\n  if (\n    block &&\n    !schema.isVoid(block) &&\n    block.text === '' &&\n    document.nodes.size !== 1\n  ) {\n    const nextBlock = document.getNextBlock(block.key)\n    change.removeNodeByKey(block.key, { normalize })\n\n    if (nextBlock && nextBlock.key) {\n      change.moveToStartOfNode(nextBlock)\n    }\n    return\n  }\n\n  // If the range is at the start of the document, abort.\n  if (start.isAtEndOfNode(document)) {\n    return\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  const text = document.getDescendant(start.key)\n\n  if (start.isAtEndOfNode(text)) {\n    const next = document.getNextText(text.key)\n    const nextBlock = document.getClosestBlock(next.key)\n    const nextVoid = document.getClosestVoid(next.key, schema)\n\n    // If the next text node has a void parent, remove it.\n    if (nextVoid) {\n      change.removeNodeByKey(nextVoid.key, { normalize })\n      return\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n == 1 && nextBlock != block) {\n      range = range.moveFocusTo(next.key, 0)\n      change.deleteAtRange(range, { normalize })\n      return\n    }\n  }\n\n  // If the remaining characters to the end of the node is greater than or equal\n  // to the number of characters to delete, just remove the characters forwards\n  // inside the current node.\n  if (n <= text.text.length - focus.offset) {\n    range = range.moveFocusForward(n)\n    change.deleteAtRange(range, { normalize })\n    return\n  }\n\n  // Otherwise, we need to see how many nodes forwards to go.\n  let node = text\n  let offset = focus.offset\n  let traversed = text.text.length - focus.offset\n\n  while (n > traversed) {\n    node = document.getNextText(node.key)\n    const next = traversed + node.text.length\n\n    if (n <= next) {\n      offset = n - traversed\n      break\n    } else {\n      traversed = next\n    }\n  }\n\n  range = range.moveFocusTo(node.key, offset)\n  change.deleteAtRange(range, { normalize })\n}\n\n/**\n * Insert a `block` node at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Block|String|Object} block\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertBlockAtRange = (change, range, block, options = {}) => {\n  block = Block.create(block)\n  const normalize = change.getFlag('normalize', options)\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range)\n    range = range.moveToStart()\n  }\n\n  const { value } = change\n  const { document, schema } = value\n  const { start } = range\n  let startKey = start.key\n  let startOffset = start.offset\n  const startBlock = document.getClosestBlock(startKey)\n  const startInline = document.getClosestInline(startKey)\n  const parent = document.getParent(startBlock.key)\n  const index = parent.nodes.indexOf(startBlock)\n\n  if (schema.isVoid(startBlock)) {\n    const extra = start.isAtEndOfNode(startBlock) ? 1 : 0\n    change.insertNodeByKey(parent.key, index + extra, block, { normalize })\n  } else if (!startInline && startBlock.text === '') {\n    change.insertNodeByKey(parent.key, index + 1, block, { normalize })\n  } else if (start.isAtStartOfNode(startBlock)) {\n    change.insertNodeByKey(parent.key, index, block, { normalize })\n  } else if (start.isAtEndOfNode(startBlock)) {\n    change.insertNodeByKey(parent.key, index + 1, block, { normalize })\n  } else {\n    if (startInline && schema.isVoid(startInline)) {\n      const atEnd = start.isAtEndOfNode(startInline)\n      const siblingText = atEnd\n        ? document.getNextText(startKey)\n        : document.getPreviousText(startKey)\n\n      const splitRange = atEnd\n        ? range.moveToStartOfNode(siblingText)\n        : range.moveToEndOfNode(siblingText)\n\n      startKey = splitRange.start.key\n      startOffset = splitRange.start.offset\n    }\n\n    change.splitDescendantsByKey(startBlock.key, startKey, startOffset, {\n      normalize: false,\n    })\n\n    change.insertNodeByKey(parent.key, index + 1, block, { normalize })\n  }\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Insert a `fragment` at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Document} fragment\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertFragmentAtRange = (change, range, fragment, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n\n  // If the range is expanded, delete it first.\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: false })\n\n    if (change.value.document.getDescendant(range.start.key)) {\n      range = range.moveToStart()\n    } else {\n      range = range.moveTo(range.end.key, 0).normalize(change.value.document)\n    }\n  }\n\n  // If the fragment is empty, there's nothing to do after deleting.\n  if (!fragment.nodes.size) return\n\n  // Regenerate the keys for all of the fragments nodes, so that they're\n  // guaranteed not to collide with the existing keys in the document. Otherwise\n  // they will be rengerated automatically and we won't have an easy way to\n  // reference them.\n  fragment = fragment.mapDescendants(child => child.regenerateKey())\n\n  // Calculate a few things...\n  const { start } = range\n  const { value } = change\n  const { schema } = value\n  let { document } = value\n  let startText = document.getDescendant(start.key)\n  let startBlock = document.getClosestBlock(startText.key)\n  let startChild = startBlock.getFurthestAncestor(startText.key)\n  const isAtStart = start.isAtStartOfNode(startBlock)\n  const parent = document.getParent(startBlock.key)\n  const index = parent.nodes.indexOf(startBlock)\n  const blocks = fragment.getBlocks()\n  const firstChild = fragment.nodes.first()\n  const lastChild = fragment.nodes.last()\n  const firstBlock = blocks.first()\n  const lastBlock = blocks.last()\n\n  // If the fragment only contains a void block, use `insertBlock` instead.\n  if (firstBlock === lastBlock && schema.isVoid(firstBlock)) {\n    change.insertBlockAtRange(range, firstBlock, options)\n    return\n  }\n\n  // If the fragment starts or ends with single nested block, (e.g., table),\n  // do not merge this fragment with existing blocks.\n  if (firstChild.hasBlockChildren() || lastChild.hasBlockChildren()) {\n    fragment.nodes.reverse().forEach(node => {\n      change.insertBlockAtRange(range, node, options)\n    })\n    return\n  }\n\n  // If the first and last block aren't the same, we need to insert all of the\n  // nodes after the fragment's first block at the index.\n  if (firstBlock != lastBlock) {\n    const lonelyParent = fragment.getFurthest(\n      firstBlock.key,\n      p => p.nodes.size == 1\n    )\n    const lonelyChild = lonelyParent || firstBlock\n    const startIndex = parent.nodes.indexOf(startBlock)\n    fragment = fragment.removeNode(lonelyChild.key)\n\n    fragment.nodes.forEach((node, i) => {\n      const newIndex = startIndex + i + 1\n      change.insertNodeByKey(parent.key, newIndex, node, { normalize: false })\n    })\n  }\n\n  // Check if we need to split the node.\n  if (start.offset != 0) {\n    change.splitDescendantsByKey(startChild.key, start.key, start.offset, {\n      normalize: false,\n    })\n  }\n\n  // Update our variables with the new value.\n  document = change.value.document\n  startText = document.getDescendant(start.key)\n  startBlock = document.getClosestBlock(start.key)\n  startChild = startBlock.getFurthestAncestor(startText.key)\n\n  // If the first and last block aren't the same, we need to move any of the\n  // starting block's children after the split into the last block of the\n  // fragment, which has already been inserted.\n  if (firstBlock != lastBlock) {\n    const nextChild = isAtStart\n      ? startChild\n      : startBlock.getNextSibling(startChild.key)\n    const nextNodes = nextChild\n      ? startBlock.nodes.skipUntil(n => n.key == nextChild.key)\n      : List()\n    const lastIndex = lastBlock.nodes.size\n\n    nextNodes.forEach((node, i) => {\n      const newIndex = lastIndex + i\n\n      change.moveNodeByKey(node.key, lastBlock.key, newIndex, {\n        normalize: false,\n      })\n    })\n  }\n\n  // If the starting block is empty, we replace it entirely with the first block\n  // of the fragment, since this leads to a more expected behavior for the user.\n  if (!schema.isVoid(startBlock) && startBlock.text === '') {\n    change.removeNodeByKey(startBlock.key, { normalize: false })\n    change.insertNodeByKey(parent.key, index, firstBlock, { normalize: false })\n  } else {\n    // Otherwise, we maintain the starting block, and insert all of the first\n    // block's inline nodes into it at the split point.\n    const inlineChild = startBlock.getFurthestAncestor(startText.key)\n    const inlineIndex = startBlock.nodes.indexOf(inlineChild)\n\n    firstBlock.nodes.forEach((inline, i) => {\n      const o = start.offset == 0 ? 0 : 1\n      const newIndex = inlineIndex + i + o\n\n      change.insertNodeByKey(startBlock.key, newIndex, inline, {\n        normalize: false,\n      })\n    })\n  }\n\n  // Normalize if requested.\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Insert an `inline` node at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Inline|String|Object} inline\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertInlineAtRange = (change, range, inline, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  inline = Inline.create(inline)\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: false })\n    range = range.moveToStart()\n  }\n\n  const { value } = change\n  const { document, schema } = value\n  const { start } = range\n  const parent = document.getParent(start.key)\n  const startText = document.assertDescendant(start.key)\n  const index = parent.nodes.indexOf(startText)\n\n  if (schema.isVoid(parent)) return\n\n  change.splitNodeByKey(start.key, start.offset, { normalize: false })\n  change.insertNodeByKey(parent.key, index + 1, inline, { normalize: false })\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Insert `text` at a `range`, with optional `marks`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertTextAtRange = (change, range, text, marks, options = {}) => {\n  let { normalize } = options\n  const { value } = change\n  const { document, schema } = value\n  const { start } = range\n  let key = start.key\n  let offset = start.offset\n  const parent = document.getParent(start.key)\n  if (schema.isVoid(parent)) return\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: false })\n\n    // Update range start after delete\n    if (change.value.selection.start.key !== key) {\n      key = change.value.selection.start.key\n      offset = change.value.selection.start.offset\n    }\n  }\n\n  // PERF: Unless specified, don't normalize if only inserting text.\n  if (normalize === undefined) {\n    normalize = range.isExpanded && marks && marks.size !== 0\n  }\n\n  change.insertTextByKey(key, offset, text, marks, { normalize: false })\n\n  if (normalize) {\n    // normalize in the narrowest existing block that originally contains startKey and endKey\n    const commonAncestor = document.getCommonAncestor(start.key, range.end.key)\n    const ancestors = document\n      .getAncestors(commonAncestor.key)\n      .push(commonAncestor)\n    const normalizeAncestor = ancestors.findLast(n =>\n      change.value.document.getDescendant(n.key)\n    )\n    // it is possible that normalizeAncestor doesn't return any node\n    // on that case fallback to startKey to be normalized\n    const normalizeKey = normalizeAncestor ? normalizeAncestor.key : start.key\n    change.normalizeNodeByKey(normalizeKey)\n  }\n}\n\n/**\n * Remove an existing `mark` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mark|String} mark (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.removeMarkAtRange = (change, range, mark, options = {}) => {\n  if (range.isCollapsed) return\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const texts = document.getTextsAtRange(range)\n  const { start, end } = range\n\n  texts.forEach(node => {\n    const { key } = node\n    let index = 0\n    let length = node.text.length\n\n    if (key == start.key) index = start.offset\n    if (key == end.key) length = end.offset\n    if (key == start.key && key == end.key) length = end.offset - start.offset\n\n    change.removeMarkByKey(key, index, length, mark, { normalize })\n  })\n}\n\n/**\n * Set the `properties` of block nodes in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.setBlocksAtRange = (change, range, properties, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document, schema } = value\n  const blocks = document.getBlocksAtRange(range)\n\n  const { start, end, isCollapsed } = range\n  const isStartVoid = document.hasVoidParent(start.key, schema)\n  const startBlock = document.getClosestBlock(start.key)\n  const endBlock = document.getClosestBlock(end.key)\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  const isHanging =\n    isCollapsed == false &&\n    start.offset == 0 &&\n    end.offset == 0 &&\n    isStartVoid == false &&\n    start.key == startBlock.getFirstText().key &&\n    end.key == endBlock.getFirstText().key\n\n  // If it's a hanging selection, ignore the last block.\n  const sets = isHanging ? blocks.slice(0, -1) : blocks\n\n  sets.forEach(block => {\n    change.setNodeByKey(block.key, properties, { normalize })\n  })\n}\n\n/**\n * Set the `properties` of inline nodes in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.setInlinesAtRange = (change, range, properties, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const inlines = document.getInlinesAtRange(range)\n\n  inlines.forEach(inline => {\n    change.setNodeByKey(inline.key, properties, { normalize })\n  })\n}\n\n/**\n * Split the block nodes at a `range`, to optional `height`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} height (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.splitBlockAtRange = (change, range, height = 1, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { start, end } = range\n  let { value } = change\n  let { document } = value\n  let node = document.assertDescendant(start.key)\n  let parent = document.getClosestBlock(node.key)\n  let h = 0\n\n  while (parent && parent.object == 'block' && h < height) {\n    node = parent\n    parent = document.getClosestBlock(parent.key)\n    h++\n  }\n\n  change.splitDescendantsByKey(node.key, start.key, start.offset, {\n    normalize: normalize && range.isCollapsed,\n  })\n\n  value = change.value\n  document = value.document\n\n  if (range.isExpanded) {\n    if (range.isBackward) range = range.flip()\n    const nextBlock = document.getNextBlock(node.key)\n    range = range.moveAnchorToStartOfNode(nextBlock)\n    range = range.setFocus(range.focus.setPath(null))\n\n    if (start.key === end.key) {\n      range = range.moveFocusTo(range.anchor.key, end.offset - start.offset)\n    }\n\n    range = document.resolveRange(range)\n    change.deleteAtRange(range, { normalize })\n  }\n}\n\n/**\n * Split the inline nodes at a `range`, to optional `height`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} height (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.splitInlineAtRange = (\n  change,\n  range,\n  height = Infinity,\n  options = {}\n) => {\n  const normalize = change.getFlag('normalize', options)\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize })\n    range = range.moveToStart()\n  }\n\n  const { start } = range\n  const { value } = change\n  const { document } = value\n  let node = document.assertDescendant(start.key)\n  let parent = document.getClosestInline(node.key)\n  let h = 0\n\n  while (parent && parent.object == 'inline' && h < height) {\n    node = parent\n    parent = document.getClosestInline(parent.key)\n    h++\n  }\n\n  change.splitDescendantsByKey(node.key, start.key, start.offset, { normalize })\n}\n\n/**\n * Add or remove a `mark` from the characters at `range`, depending on whether\n * it's already there.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.toggleMarkAtRange = (change, range, mark, options = {}) => {\n  if (range.isCollapsed) return\n\n  mark = Mark.create(mark)\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const marks = document.getActiveMarksAtRange(range)\n  const exists = marks.some(m => m.equals(mark))\n\n  if (exists) {\n    change.removeMarkAtRange(range, mark, { normalize })\n  } else {\n    change.addMarkAtRange(range, mark, { normalize })\n  }\n}\n\n/**\n * Unwrap all of the block nodes in a `range` from a block with `properties`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String|Object} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.unwrapBlockAtRange = (change, range, properties, options = {}) => {\n  properties = Node.createProperties(properties)\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  let { document } = value\n  const blocks = document.getBlocksAtRange(range)\n  const wrappers = blocks\n    .map(block => {\n      return document.getClosest(block.key, parent => {\n        if (parent.object != 'block') return false\n        if (properties.type != null && parent.type != properties.type)\n          return false\n        if (properties.data != null && !parent.data.isSuperset(properties.data))\n          return false\n        return true\n      })\n    })\n    .filter(exists => exists)\n    .toOrderedSet()\n    .toList()\n\n  wrappers.forEach(block => {\n    const first = block.nodes.first()\n    const last = block.nodes.last()\n    const parent = document.getParent(block.key)\n    const index = parent.nodes.indexOf(block)\n\n    const children = block.nodes.filter(child => {\n      return blocks.some(b => child == b || child.hasDescendant(b.key))\n    })\n\n    const firstMatch = children.first()\n    const lastMatch = children.last()\n\n    if (first == firstMatch && last == lastMatch) {\n      block.nodes.forEach((child, i) => {\n        change.moveNodeByKey(child.key, parent.key, index + i, {\n          normalize: false,\n        })\n      })\n\n      change.removeNodeByKey(block.key, { normalize: false })\n    } else if (last == lastMatch) {\n      block.nodes.skipUntil(n => n == firstMatch).forEach((child, i) => {\n        change.moveNodeByKey(child.key, parent.key, index + 1 + i, {\n          normalize: false,\n        })\n      })\n    } else if (first == firstMatch) {\n      block.nodes\n        .takeUntil(n => n == lastMatch)\n        .push(lastMatch)\n        .forEach((child, i) => {\n          change.moveNodeByKey(child.key, parent.key, index + i, {\n            normalize: false,\n          })\n        })\n    } else {\n      const firstText = firstMatch.getFirstText()\n\n      change.splitDescendantsByKey(block.key, firstText.key, 0, {\n        normalize: false,\n      })\n\n      document = change.value.document\n\n      children.forEach((child, i) => {\n        if (i == 0) {\n          const extra = child\n          child = document.getNextBlock(child.key)\n          change.removeNodeByKey(extra.key, { normalize: false })\n        }\n\n        change.moveNodeByKey(child.key, parent.key, index + 1 + i, {\n          normalize: false,\n        })\n      })\n    }\n  })\n\n  // TODO: optmize to only normalize the right block\n  if (normalize) {\n    change.normalizeDocument()\n  }\n}\n\n/**\n * Unwrap the inline nodes in a `range` from an inline with `properties`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String|Object} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.unwrapInlineAtRange = (change, range, properties, options = {}) => {\n  properties = Node.createProperties(properties)\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const texts = document.getTextsAtRange(range)\n  const inlines = texts\n    .map(text => {\n      return document.getClosest(text.key, parent => {\n        if (parent.object != 'inline') return false\n        if (properties.type != null && parent.type != properties.type)\n          return false\n        if (properties.data != null && !parent.data.isSuperset(properties.data))\n          return false\n        return true\n      })\n    })\n    .filter(exists => exists)\n    .toOrderedSet()\n    .toList()\n\n  inlines.forEach(inline => {\n    const parent = change.value.document.getParent(inline.key)\n    const index = parent.nodes.indexOf(inline)\n\n    inline.nodes.forEach((child, i) => {\n      change.moveNodeByKey(child.key, parent.key, index + i, {\n        normalize: false,\n      })\n    })\n\n    change.removeNodeByKey(inline.key, { normalize: false })\n  })\n\n  // TODO: optmize to only normalize the right block\n  if (normalize) {\n    change.normalizeDocument()\n  }\n}\n\n/**\n * Wrap all of the blocks in a `range` in a new `block`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Block|Object|String} block\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.wrapBlockAtRange = (change, range, block, options = {}) => {\n  block = Block.create(block)\n  block = block.set('nodes', block.nodes.clear())\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n\n  const blocks = document.getBlocksAtRange(range)\n  const firstblock = blocks.first()\n  const lastblock = blocks.last()\n  let parent, siblings, index\n\n  // If there is only one block in the selection then we know the parent and\n  // siblings.\n  if (blocks.length === 1) {\n    parent = document.getParent(firstblock.key)\n    siblings = blocks\n  } else {\n    // Determine closest shared parent to all blocks in selection.\n    parent = document.getClosest(firstblock.key, p1 => {\n      return !!document.getClosest(lastblock.key, p2 => p1 == p2)\n    })\n  }\n\n  // If no shared parent could be found then the parent is the document.\n  if (parent == null) parent = document\n\n  // Create a list of direct children siblings of parent that fall in the\n  // selection.\n  if (siblings == null) {\n    const indexes = parent.nodes.reduce((ind, node, i) => {\n      if (node == firstblock || node.hasDescendant(firstblock.key)) ind[0] = i\n      if (node == lastblock || node.hasDescendant(lastblock.key)) ind[1] = i\n      return ind\n    }, [])\n\n    index = indexes[0]\n    siblings = parent.nodes.slice(indexes[0], indexes[1] + 1)\n  }\n\n  // Get the index to place the new wrapped node at.\n  if (index == null) {\n    index = parent.nodes.indexOf(siblings.first())\n  }\n\n  // Inject the new block node into the parent.\n  change.insertNodeByKey(parent.key, index, block, { normalize: false })\n\n  // Move the sibling nodes into the new block node.\n  siblings.forEach((node, i) => {\n    change.moveNodeByKey(node.key, block.key, i, { normalize: false })\n  })\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Wrap the text and inlines in a `range` in a new `inline`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Inline|Object|String} inline\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.wrapInlineAtRange = (change, range, inline, options = {}) => {\n  const { value } = change\n  let { document, schema } = value\n  const normalize = change.getFlag('normalize', options)\n  const { start, end } = range\n\n  if (range.isCollapsed) {\n    // Wrapping an inline void\n    const inlineParent = document.getClosestInline(start.key)\n\n    if (!schema.isVoid(inlineParent)) {\n      return\n    }\n\n    return change.wrapInlineByKey(inlineParent.key, inline, options)\n  }\n\n  inline = Inline.create(inline)\n  inline = inline.set('nodes', inline.nodes.clear())\n\n  const blocks = document.getBlocksAtRange(range)\n  let startBlock = document.getClosestBlock(start.key)\n  let endBlock = document.getClosestBlock(end.key)\n  const startInline = document.getClosestInline(start.key)\n  const endInline = document.getClosestInline(end.key)\n  let startChild = startBlock.getFurthestAncestor(start.key)\n  let endChild = endBlock.getFurthestAncestor(end.key)\n\n  if (!startInline || startInline != endInline) {\n    change.splitDescendantsByKey(endChild.key, end.key, end.offset, {\n      normalize: false,\n    })\n\n    change.splitDescendantsByKey(startChild.key, start.key, start.offset, {\n      normalize: false,\n    })\n  }\n\n  document = change.value.document\n  startBlock = document.getDescendant(startBlock.key)\n  endBlock = document.getDescendant(endBlock.key)\n  startChild = startBlock.getFurthestAncestor(start.key)\n  endChild = endBlock.getFurthestAncestor(end.key)\n  const startIndex = startBlock.nodes.indexOf(startChild)\n  const endIndex = endBlock.nodes.indexOf(endChild)\n\n  if (startInline && startInline == endInline) {\n    const text = startBlock\n      .getTextsAtRange(range)\n      .get(0)\n      .splitText(start.offset)[1]\n      .splitText(end.offset - start.offset)[0]\n    inline = inline.set('nodes', List([text]))\n    Changes.insertInlineAtRange(change, range, inline, { normalize: false })\n    const inlinekey = inline.getFirstText().key\n    const rng = {\n      anchor: {\n        key: inlinekey,\n        offset: 0,\n      },\n      focus: {\n        key: inlinekey,\n        offset: end.offset - start.offset,\n      },\n      isFocused: true,\n    }\n    change.select(rng)\n  } else if (startBlock == endBlock) {\n    document = change.value.document\n    startBlock = document.getClosestBlock(start.key)\n    startChild = startBlock.getFurthestAncestor(start.key)\n\n    const startInner = document.getNextSibling(startChild.key)\n    const startInnerIndex = startBlock.nodes.indexOf(startInner)\n    const endInner =\n      start.key == end.key\n        ? startInner\n        : startBlock.getFurthestAncestor(end.key)\n    const inlines = startBlock.nodes\n      .skipUntil(n => n == startInner)\n      .takeUntil(n => n == endInner)\n      .push(endInner)\n\n    const node = inline.regenerateKey()\n\n    change.insertNodeByKey(startBlock.key, startInnerIndex, node, {\n      normalize: false,\n    })\n\n    inlines.forEach((child, i) => {\n      change.moveNodeByKey(child.key, node.key, i, { normalize: false })\n    })\n\n    if (normalize) {\n      change.normalizeNodeByKey(startBlock.key)\n    }\n  } else {\n    const startInlines = startBlock.nodes.slice(startIndex + 1)\n    const endInlines = endBlock.nodes.slice(0, endIndex + 1)\n    const startNode = inline.regenerateKey()\n    const endNode = inline.regenerateKey()\n\n    change.insertNodeByKey(startBlock.key, startIndex + 1, startNode, {\n      normalize: false,\n    })\n\n    change.insertNodeByKey(endBlock.key, endIndex, endNode, {\n      normalize: false,\n    })\n\n    startInlines.forEach((child, i) => {\n      change.moveNodeByKey(child.key, startNode.key, i, { normalize: false })\n    })\n\n    endInlines.forEach((child, i) => {\n      change.moveNodeByKey(child.key, endNode.key, i, { normalize: false })\n    })\n\n    if (normalize) {\n      change.normalizeNodeByKey(startBlock.key).normalizeNodeByKey(endBlock.key)\n    }\n\n    blocks.slice(1, -1).forEach(block => {\n      const node = inline.regenerateKey()\n      change.insertNodeByKey(block.key, 0, node, { normalize: false })\n\n      block.nodes.forEach((child, i) => {\n        change.moveNodeByKey(child.key, node.key, i, { normalize: false })\n      })\n\n      if (normalize) {\n        change.normalizeNodeByKey(block.key)\n      }\n    })\n  }\n}\n\n/**\n * Wrap the text in a `range` in a prefix/suffix.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String} prefix\n * @param {String} suffix (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.wrapTextAtRange = (\n  change,\n  range,\n  prefix,\n  suffix = prefix,\n  options = {}\n) => {\n  const normalize = change.getFlag('normalize', options)\n  const { start, end } = range\n  const startRange = range.moveToStart()\n  let endRange = range.moveToEnd()\n\n  if (start.key == end.key) {\n    endRange = endRange.moveForward(prefix.length)\n  }\n\n  change.insertTextAtRange(startRange, prefix, [], { normalize })\n  change.insertTextAtRange(endRange, suffix, [], { normalize })\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import { List } from 'immutable'\n\n/**\n * Compare paths `path` and `b` to see which is before or after.\n *\n * @param {List} path\n * @param {List} b\n * @return {Number|Null}\n */\n\nfunction compare(path, target) {\n  // PERF: if the paths are the same we can exit early.\n  if (path.size !== target.size) return null\n\n  for (let i = 0; i < path.size; i++) {\n    const pv = path.get(i)\n    const tv = target.get(i)\n\n    // If the path's value is ever less than the target's, it's before.\n    if (pv < tv) return -1\n\n    // If the target's value is ever less than the path's, it's after.\n    if (pv > tv) return 1\n  }\n\n  // Otherwise they were equal the whole way, it's the same.\n  return 0\n}\n\n/**\n * Create a path from `attrs`.\n *\n * @param {Array|List} attrs\n * @return {List}\n */\n\nfunction create(attrs) {\n  if (attrs == null) {\n    return null\n  }\n\n  if (List.isList(attrs)) {\n    return attrs\n  }\n\n  if (Array.isArray(attrs)) {\n    return List(attrs)\n  }\n\n  throw new Error(\n    `Paths can only be created from arrays or lists, but you passed: ${attrs}`\n  )\n}\n\n/**\n * Crop paths `a` and `b` to an equal size, defaulting to the shortest.\n *\n * @param {List} a\n * @param {List} b\n */\n\nfunction crop(a, b, size = min(a, b)) {\n  const ca = a.slice(0, size)\n  const cb = b.slice(0, size)\n  return [ca, cb]\n}\n\n/**\n * Decrement a `path` by `n` at `index`, defaulting to the last index.\n *\n * @param {List} path\n * @param {Number} n\n * @param {Number} index\n */\n\nfunction decrement(path, n = 1, index = path.size - 1) {\n  return increment(path, 0 - n, index)\n}\n\n/**\n * Increment a `path` by `n` at `index`, defaulting to the last index.\n *\n * @param {List} path\n * @param {Number} n\n * @param {Number} index\n */\n\nfunction increment(path, n = 1, index = path.size - 1) {\n  const value = path.get(index)\n  const newValue = value + n\n  const newPath = path.set(index, newValue)\n  return newPath\n}\n\n/**\n * Is a `path` above another `target` path?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isAbove(path, target) {\n  const [p, t] = crop(path, target)\n  return path.size < target.size && compare(p, t) === 0\n}\n\n/**\n * Is a `path` after another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isAfter(path, target) {\n  const [p, t] = crop(path, target)\n  return compare(p, t) === 1\n}\n\n/**\n * Is a `path` before another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isBefore(path, target) {\n  const [p, t] = crop(path, target)\n  return compare(p, t) === -1\n}\n\n/**\n * Lift a `path` to refer to its parent.\n *\n * @param {List} path\n * @return {Array}\n */\n\nfunction lift(path) {\n  const parent = path.slice(0, -1)\n  return parent\n}\n\n/**\n * Get the maximum length of paths `a` and `b`.\n *\n * @param {List} path\n * @param {List} path\n * @return {Number}\n */\n\nfunction max(a, b) {\n  const n = Math.max(a.size, b.size)\n  return n\n}\n\n/**\n * Get the minimum length of paths `a` and `b`.\n *\n * @param {List} path\n * @param {List} path\n * @return {Number}\n */\n\nfunction min(a, b) {\n  const n = Math.min(a.size, b.size)\n  return n\n}\n\n/**\n * Get the common ancestor path of path `a` and path `b`.\n *\n * @param {List} a\n * @param {List} b\n * @return {List}\n */\n\nfunction relate(a, b) {\n  const array = []\n\n  for (let i = 0; i < a.size && i < b.size; i++) {\n    const av = a.get(i)\n    const bv = b.get(i)\n\n    // If the values aren't equal, they've diverged and don't share an ancestor.\n    if (av !== bv) break\n\n    // Otherwise, the current value is still a common ancestor.\n    array.push(av)\n  }\n\n  const path = create(array)\n  return path\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  compare,\n  create,\n  crop,\n  decrement,\n  increment,\n  isAbove,\n  isAfter,\n  isBefore,\n  lift,\n  max,\n  min,\n  relate,\n}\n","import Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport PathUtils from '../utils/path-utils'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Add mark to text at `offset` and `length` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mixed} mark\n * @param {Object} options\n */\n\nChanges.addMarkByPath = (change, path, offset, length, mark, options) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n  const leaves = node.getLeaves()\n\n  const operations = []\n  const bx = offset\n  const by = offset + length\n  let o = 0\n\n  leaves.forEach(leaf => {\n    const ax = o\n    const ay = ax + leaf.text.length\n\n    o += leaf.text.length\n\n    // If the leaf doesn't overlap with the operation, continue on.\n    if (ay < bx || by < ax) return\n\n    // If the leaf already has the mark, continue on.\n    if (leaf.marks.has(mark)) return\n\n    // Otherwise, determine which offset and characters overlap.\n    const start = Math.max(ax, bx)\n    const end = Math.min(ay, by)\n\n    operations.push({\n      type: 'add_mark',\n      value,\n      path,\n      offset: start,\n      length: end - start,\n      mark,\n    })\n  })\n\n  change.applyOperations(operations)\n  change.normalizeParentByPath(path, options)\n}\n\n/**\n * Insert a `fragment` at `index` in a node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} index\n * @param {Fragment} fragment\n * @param {Object} options\n */\n\nChanges.insertFragmentByPath = (change, path, index, fragment, options) => {\n  fragment.nodes.forEach((node, i) => {\n    change.insertNodeByPath(path, index + i, node)\n  })\n\n  change.normalizeNodeByPath(path, options)\n}\n\n/**\n * Insert a `node` at `index` in a node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} index\n * @param {Node} node\n * @param {Object} options\n */\n\nChanges.insertNodeByPath = (change, path, index, node, options) => {\n  const { value } = change\n\n  change.applyOperation({\n    type: 'insert_node',\n    value,\n    path: path.concat(index),\n    node,\n  })\n\n  change.normalizeNodeByPath(path, options)\n}\n\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} offset\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n */\n\nChanges.insertTextByPath = (change, path, offset, text, marks, options) => {\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n  marks = marks || node.getMarksAtIndex(offset)\n\n  change.applyOperation({\n    type: 'insert_text',\n    value,\n    path,\n    offset,\n    text,\n    marks,\n  })\n\n  change.normalizeParentByPath(path, options)\n}\n\n/**\n * Merge a node by `path` with the previous node.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object} options\n */\n\nChanges.mergeNodeByPath = (change, path, options) => {\n  const { value } = change\n  const { document } = value\n  const original = document.getDescendant(path)\n  const previous = document.getPreviousSibling(path)\n\n  if (!previous) {\n    throw new Error(\n      `Unable to merge node with path \"${path}\", because it has no previous sibling.`\n    )\n  }\n\n  const position =\n    previous.object == 'text' ? previous.text.length : previous.nodes.size\n\n  change.applyOperation({\n    type: 'merge_node',\n    value,\n    path,\n    position,\n    // for undos to succeed we only need the type and data because\n    // these are the only properties that get changed in the merge operation\n    properties: {\n      type: original.type,\n      data: original.data,\n    },\n    target: null,\n  })\n\n  change.normalizeParentByPath(path, options)\n}\n\n/**\n * Move a node by `path` to a new parent by `newPath` and `index`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {String} newPath\n * @param {Number} index\n * @param {Object} options\n */\n\nChanges.moveNodeByPath = (change, path, newPath, newIndex, options) => {\n  const { value } = change\n\n  change.applyOperation({\n    type: 'move_node',\n    value,\n    path,\n    newPath: newPath.concat(newIndex),\n  })\n\n  const ancestorPath = PathUtils.relate(path, newPath)\n  change.normalizeNodeByPath(ancestorPath, options)\n}\n\n/**\n * Remove mark from text at `offset` and `length` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n * @param {Object} options\n */\n\nChanges.removeMarkByPath = (change, path, offset, length, mark, options) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n  const leaves = node.getLeaves()\n\n  const operations = []\n  const bx = offset\n  const by = offset + length\n  let o = 0\n\n  leaves.forEach(leaf => {\n    const ax = o\n    const ay = ax + leaf.text.length\n\n    o += leaf.text.length\n\n    // If the leaf doesn't overlap with the operation, continue on.\n    if (ay < bx || by < ax) return\n\n    // If the leaf already has the mark, continue on.\n    if (!leaf.marks.has(mark)) return\n\n    // Otherwise, determine which offset and characters overlap.\n    const start = Math.max(ax, bx)\n    const end = Math.min(ay, by)\n\n    operations.push({\n      type: 'remove_mark',\n      value,\n      path,\n      offset: start,\n      length: end - start,\n      mark,\n    })\n  })\n\n  change.applyOperations(operations)\n  change.normalizeParentByPath(path, options)\n}\n\n/**\n * Remove all `marks` from node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object} options\n */\n\nChanges.removeAllMarksByPath = (change, path, options) => {\n  const { state } = change\n  const { document } = state\n  const node = document.assertNode(path)\n  const texts = node.object === 'text' ? [node] : node.getTextsAsArray()\n\n  texts.forEach(text => {\n    text.getMarksAsArray().forEach(mark => {\n      change.removeMarkByKey(text.key, 0, text.text.length, mark, options)\n    })\n  })\n}\n\n/**\n * Remove a node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object} options\n */\n\nChanges.removeNodeByPath = (change, path, options) => {\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n\n  change.applyOperation({\n    type: 'remove_node',\n    value,\n    path,\n    node,\n  })\n\n  change.normalizeParentByPath(path, options)\n}\n\n/**\n * Remove text at `offset` and `length` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Object} options\n */\n\nChanges.removeTextByPath = (change, path, offset, length, options) => {\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n  const leaves = node.getLeaves()\n  const { text } = node\n\n  const removals = []\n  const bx = offset\n  const by = offset + length\n  let o = 0\n\n  leaves.forEach(leaf => {\n    const ax = o\n    const ay = ax + leaf.text.length\n\n    o += leaf.text.length\n\n    // If the leaf doesn't overlap with the removal, continue on.\n    if (ay < bx || by < ax) return\n\n    // Otherwise, determine which offset and characters overlap.\n    const start = Math.max(ax, bx)\n    const end = Math.min(ay, by)\n    const string = text.slice(start, end)\n\n    removals.push({\n      type: 'remove_text',\n      value,\n      path,\n      offset: start,\n      text: string,\n      marks: leaf.marks,\n    })\n  })\n\n  // Apply in reverse order, so subsequent removals don't impact previous ones.\n  change.applyOperations(removals.reverse())\n\n  const block = document.getClosestBlock(node.key)\n  change.normalizeNodeByKey(block.key, options)\n}\n\n/**\n`* Replace a `node` with another `node`\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object|Node} node\n * @param {Object} options\n */\n\nChanges.replaceNodeByPath = (change, path, newNode, options) => {\n  newNode = Node.create(newNode)\n  const index = path.last()\n  const parentPath = PathUtils.lift(path)\n  change.removeNodeByPath(path, { normalize: false })\n  change.insertNodeByPath(parentPath, index, newNode, { normalize: false })\n  change.normalizeParentByPath(path, options)\n}\n\n/**\n * Replace A Length of Text with another string or text\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {string} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n */\n\nChanges.replaceTextByPath = (\n  change,\n  path,\n  offset,\n  length,\n  text,\n  marks,\n  options\n) => {\n  const { document } = change.value\n  const node = document.assertNode(path)\n\n  if (length + offset > node.text.length) {\n    length = node.text.length - offset\n  }\n\n  const range = document.createRange({\n    anchor: { path, offset },\n    focus: { path, offset: offset + length },\n  })\n\n  let activeMarks = document.getActiveMarksAtRange(range)\n\n  change.removeTextByPath(path, offset, length, { normalize: false })\n\n  if (!marks) {\n    // Do not use mark at index when marks and activeMarks are both empty\n    marks = activeMarks ? activeMarks : []\n  } else if (activeMarks) {\n    // Do not use `has` because we may want to reset marks like font-size with\n    // an updated data;\n    activeMarks = activeMarks.filter(\n      activeMark => !marks.find(m => activeMark.type === m.type)\n    )\n\n    marks = activeMarks.merge(marks)\n  }\n\n  change.insertTextByPath(path, offset, text, marks, options)\n}\n\n/**\n * Set `properties` on mark on text at `offset` and `length` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n * @param {Object} options\n */\n\nChanges.setMarkByPath = (\n  change,\n  path,\n  offset,\n  length,\n  mark,\n  properties,\n  options\n) => {\n  mark = Mark.create(mark)\n  properties = Mark.createProperties(properties)\n  const { value } = change\n\n  change.applyOperation({\n    type: 'set_mark',\n    value,\n    path,\n    offset,\n    length,\n    mark,\n    properties,\n  })\n\n  change.normalizeParentByPath(path, options)\n}\n\n/**\n * Set `properties` on a node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object|String} properties\n * @param {Object} options\n */\n\nChanges.setNodeByPath = (change, path, properties, options) => {\n  properties = Node.createProperties(properties)\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n\n  change.applyOperation({\n    type: 'set_node',\n    value,\n    path,\n    node,\n    properties,\n  })\n\n  change.normalizeNodeByPath(path, options)\n}\n\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n */\n\nChanges.setTextByPath = (change, path, text, marks, options) => {\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n  const end = node.text.length\n  change.replaceTextByPath(path, 0, end, text, marks, options)\n}\n\n/**\n * Split a node by `path` at `position`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} position\n * @param {Object} options\n */\n\nChanges.splitNodeByPath = (change, path, position, options = {}) => {\n  const { target = null } = options\n  const { value } = change\n  const { document } = value\n  const node = document.getDescendant(path)\n\n  change.applyOperation({\n    type: 'split_node',\n    value,\n    path,\n    position,\n    properties: {\n      type: node.type,\n      data: node.data,\n    },\n    target,\n  })\n\n  change.normalizeParentByPath(path, options)\n}\n\n/**\n * Split a node deeply down the tree by `path`, `textPath` and `textOffset`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Array} textPath\n * @param {Number} textOffset\n * @param {Object} options\n */\n\nChanges.splitDescendantsByPath = (\n  change,\n  path,\n  textPath,\n  textOffset,\n  options\n) => {\n  if (path.equals(textPath)) {\n    change.splitNodeByPath(textPath, textOffset, options)\n    return\n  }\n\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n  const text = document.assertNode(textPath)\n  const ancestors = document.getAncestors(textPath)\n  const nodes = ancestors\n    .skipUntil(a => a.key == node.key)\n    .reverse()\n    .unshift(text)\n\n  let previous\n  let index\n\n  nodes.forEach(n => {\n    const prevIndex = index == null ? null : index\n    index = previous ? n.nodes.indexOf(previous) + 1 : textOffset\n    previous = n\n\n    change.splitNodeByKey(n.key, index, {\n      normalize: false,\n      target: prevIndex,\n    })\n  })\n\n  change.normalizeParentByPath(path, options)\n}\n\n/**\n * Unwrap content from an inline parent with `properties`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object|String} properties\n * @param {Object} options\n */\n\nChanges.unwrapInlineByPath = (change, path, properties, options) => {\n  const { value } = change\n  const { document, selection } = value\n  const node = document.assertNode(path)\n  const first = node.getFirstText()\n  const last = node.getLastText()\n  const range = selection.moveToRangeOfNode(first, last)\n  change.unwrapInlineAtRange(range, properties, options)\n}\n\n/**\n * Unwrap content from a block parent with `properties`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object|String} properties\n * @param {Object} options\n */\n\nChanges.unwrapBlockByPath = (change, path, properties, options) => {\n  const { value } = change\n  const { document, selection } = value\n  const node = document.assertNode(path)\n  const first = node.getFirstText()\n  const last = node.getLastText()\n  const range = selection.moveToRangeOfNode(first, last)\n  change.unwrapBlockAtRange(range, properties, options)\n}\n\n/**\n * Unwrap a single node from its parent.\n *\n * If the node is surrounded with siblings, its parent will be\n * split. If the node is the only child, the parent is removed, and\n * simply replaced by the node itself.  Cannot unwrap a root node.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object} options\n */\n\nChanges.unwrapNodeByPath = (change, path, options) => {\n  const { value } = change\n  const { document } = value\n  document.assertNode(path)\n\n  const parentPath = PathUtils.lift(path)\n  const parent = document.assertNode(parentPath)\n  const index = path.last()\n  const parentIndex = parentPath.last()\n  const grandPath = PathUtils.lift(parentPath)\n  const isFirst = index === 0\n  const isLast = index === parent.nodes.size - 1\n\n  if (parent.nodes.size === 1) {\n    change.moveNodeByPath(path, grandPath, parentIndex + 1, {\n      normalize: false,\n    })\n\n    change.removeNodeByPath(parentPath, options)\n  } else if (isFirst) {\n    change.moveNodeByPath(path, grandPath, parentIndex, options)\n  } else if (isLast) {\n    change.moveNodeByPath(path, grandPath, parentIndex + 1, options)\n  } else {\n    change.splitNodeByPath(parentPath, index, { normalize: false })\n\n    let updatedPath = PathUtils.increment(path, 1, parentPath.size - 1)\n    updatedPath = updatedPath.set(updatedPath.size - 1, 0)\n\n    change.moveNodeByPath(updatedPath, grandPath, parentIndex + 1, {\n      normalize: false,\n    })\n\n    change.normalizeNodeByPath(grandPath, options)\n  }\n}\n\n/**\n * Wrap a node in a block with `properties`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Block|Object|String} block\n * @param {Object} options\n */\n\nChanges.wrapBlockByPath = (change, path, block, options) => {\n  block = Block.create(block)\n  block = block.set('nodes', block.nodes.clear())\n  const parentPath = PathUtils.lift(path)\n  const index = path.last()\n  const newPath = PathUtils.increment(path)\n  change.insertNodeByPath(parentPath, index, block, { normalize: false })\n  change.moveNodeByPath(newPath, path, 0, options)\n}\n\n/**\n * Wrap a node in an inline with `properties`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Block|Object|String} inline\n * @param {Object} options\n */\n\nChanges.wrapInlineByPath = (change, path, inline, options) => {\n  inline = Inline.create(inline)\n  inline = inline.set('nodes', inline.nodes.clear())\n  const parentPath = PathUtils.lift(path)\n  const index = path.last()\n  const newPath = PathUtils.increment(path)\n  change.insertNodeByPath(parentPath, index, inline, { normalize: false })\n  change.moveNodeByPath(newPath, path, 0, options)\n}\n\n/**\n * Wrap a node by `path` with `node`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Node|Object} node\n * @param {Object} options\n */\n\nChanges.wrapNodeByPath = (change, path, node) => {\n  node = Node.create(node)\n\n  if (node.object == 'block') {\n    change.wrapBlockByPath(path, node)\n    return\n  }\n\n  if (node.object == 'inline') {\n    change.wrapInlineByPath(path, node)\n    return\n  }\n}\n\n/**\n * Mix in `*ByKey` variants.\n */\n\nconst CHANGES = [\n  'addMark',\n  'insertFragment',\n  'insertNode',\n  'insertText',\n  'mergeNode',\n  'removeMark',\n  'removeAllMarks',\n  'removeNode',\n  'setText',\n  'replaceText',\n  'removeText',\n  'replaceNode',\n  'setMark',\n  'setNode',\n  'splitNode',\n  'unwrapInline',\n  'unwrapBlock',\n  'unwrapNode',\n  'wrapBlock',\n  'wrapInline',\n  'wrapNode',\n]\n\nfor (const method of CHANGES) {\n  Changes[`${method}ByKey`] = (change, key, ...args) => {\n    const { value } = change\n    const { document } = value\n    const path = document.assertPath(key)\n    change[`${method}ByPath`](path, ...args)\n  }\n}\n\n// Moving nodes takes two keys, so it's slightly different.\nChanges.moveNodeByKey = (change, key, newKey, ...args) => {\n  const { value } = change\n  const { document } = value\n  const path = document.assertPath(key)\n  const newPath = document.assertPath(newKey)\n  change.moveNodeByPath(path, newPath, ...args)\n}\n\n// Splitting descendants takes two keys, so it's slightly different.\nChanges.splitDescendantsByKey = (change, key, textKey, ...args) => {\n  const { value } = change\n  const { document } = value\n  const path = document.assertPath(key)\n  const textPath = document.assertPath(textKey)\n  change.splitDescendantsByPath(path, textPath, ...args)\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import isPlainObject from 'is-plain-object'\nimport warning from 'slate-dev-warning'\nimport { Record } from 'immutable'\n\nimport KeyUtils from '../utils/key-utils'\nimport PathUtils from '../utils/path-utils'\nimport MODEL_TYPES from '../constants/model-types'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  key: null,\n  offset: null,\n  path: null,\n}\n\n/**\n * Point.\n *\n * @type {Point}\n */\n\nclass Point extends Record(DEFAULTS) {\n  /**\n   * Create a new `Point` with `attrs`.\n   *\n   * @param {Object|Point} attrs\n   * @return {Point}\n   */\n\n  static create(attrs = {}) {\n    if (Point.isPoint(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Point.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Point.create\\` only accepts objects or points, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable point properties from `attrs`.\n   *\n   * @param {Object|Point} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Point.isPoint(a)) {\n      return {\n        key: a.key,\n        offset: a.offset,\n        path: a.path,\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('key' in a) p.key = a.key\n      if ('offset' in a) p.offset = a.offset\n      if ('path' in a) p.path = PathUtils.create(a.path)\n\n      // If only a path is set, or only a key is set, ensure that the other is\n      // set to null so that it can be normalized back to the right value.\n      // Otherwise we won't realize that the path and key don't match anymore.\n      if ('path' in a && !('key' in a)) p.key = null\n      if ('key' in a && !('path' in a)) p.path = null\n\n      return p\n    }\n\n    throw new Error(\n      `\\`Point.createProperties\\` only accepts objects or points, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Point` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Point}\n   */\n\n  static fromJSON(object) {\n    const { key = null, offset = null, path = null } = object\n\n    const point = new Point({\n      key,\n      offset,\n      path: PathUtils.create(path),\n    })\n\n    return point\n  }\n\n  /**\n   * Check if an `obj` is a `Point`.\n   *\n   * @param {Any} obj\n   * @return {Boolean}\n   */\n\n  static isPoint(obj) {\n    return !!(obj && obj[MODEL_TYPES.POINT])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'point'\n  }\n\n  /**\n   * Check whether all properties of the point are set.\n   *\n   * @return {Boolean}\n   */\n\n  get isSet() {\n    return this.key != null && this.offset != null && this.path != null\n  }\n\n  /**\n   * Check whether any property of the point is not set.\n   *\n   * @return {Boolean}\n   */\n\n  get isUnset() {\n    return !this.isSet\n  }\n\n  /**\n   * Check whether the point is at the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isAtEndOfNode(node) {\n    if (this.isUnset) return false\n    const last = node.getLastText()\n    const is = this.key === last.key && this.offset === last.text.length\n    return is\n  }\n\n  /**\n   * Check whether the point is at the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isAtStartOfNode(node) {\n    if (this.isUnset) return false\n\n    // PERF: Do a check for a `0` offset first since it's quickest.\n    if (this.offset != 0) return false\n\n    const first = node.getFirstText()\n    const is = this.key === first.key\n    return is\n  }\n\n  /**\n   * Check whether the point is in a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isInNode(node) {\n    if (this.isUnset) return false\n    if (node.object === 'text' && node.key === this.key) return true\n    if (node.hasNode(this.key)) return true\n    return false\n  }\n\n  /**\n   * Move the point's offset backward `n` characters.\n   *\n   * @param {Number} n (optional)\n   * @return {Point}\n   */\n\n  moveBackward(n = 1) {\n    if (n === 0) return this\n    if (n < 0) return this.moveForward(-n)\n    const point = this.setOffset(this.offset - n)\n    return point\n  }\n\n  /**\n   * Move the point's offset forward `n` characters.\n   *\n   * @param {Number} n (optional)\n   * @return {Point}\n   */\n\n  moveForward(n = 1) {\n    if (n === 0) return this\n    if (n < 0) return this.moveBackward(-n)\n    const point = this.setOffset(this.offset + n)\n    return point\n  }\n\n  /**\n   * Move the point's anchor point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String|Number} path\n   * @param {Number} offset\n   * @return {Point}\n   */\n\n  moveTo(path, offset = 0) {\n    let key = this.key\n\n    if (typeof path === 'number') {\n      offset = path\n      path = this.path\n    } else if (typeof path === 'string') {\n      key = path\n      path = key === this.key ? this.path : null\n    } else {\n      key = path.equals(this.path) ? this.key : null\n    }\n\n    const point = this.merge({ key, path, offset })\n    return point\n  }\n\n  /**\n   * Move the point's anchor point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Point}\n   */\n\n  moveToStartOfNode(node) {\n    const first = node.getFirstText()\n    const point = this.moveTo(first.key, 0)\n    return point\n  }\n\n  /**\n   * Move the point's anchor point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Point}\n   */\n\n  moveToEndOfNode(node) {\n    const last = node.getLastText()\n    const point = this.moveTo(last.key, last.text.length)\n    return point\n  }\n\n  /**\n   * Normalize the point relative to a `node`, ensuring that its key and path\n   * reference a text node, or that it gets unset.\n   *\n   * @param {Node} node\n   * @return {Point}\n   */\n\n  normalize(node) {\n    // If both the key and path are null, there's no reference to a node, so\n    // make sure it is entirely unset.\n    if (this.key == null && this.path == null) {\n      return this.setOffset(null)\n    }\n\n    const { key, offset, path } = this\n    const target = node.getNode(key || path)\n\n    if (!target) {\n      warning(false, \"A point's `path` or `key` invalid and was reset!\")\n\n      const text = node.getFirstText()\n      if (!text) return Point.create()\n\n      const point = this.merge({\n        key: text.key,\n        offset: 0,\n        path: node.getPath(text.key),\n      })\n\n      return point\n    }\n\n    if (target.object !== 'text') {\n      warning(false, 'A point should not reference a non-text node!')\n\n      const text = target.getTextAtOffset(offset)\n      const before = target.getOffset(text.key)\n      const point = this.merge({\n        offset: offset - before,\n        key: text.key,\n        path: node.getPath(text.key),\n      })\n\n      return point\n    }\n\n    if (target && path && key && key !== target.key) {\n      warning(false, \"A point's `key` did not match its `path`!\")\n    }\n\n    const point = this.merge({\n      key: target.key,\n      path: path == null ? node.getPath(target.key) : path,\n      offset: offset == null ? 0 : Math.min(offset, target.text.length),\n    })\n\n    return point\n  }\n\n  /**\n   * Set the point's key to a new `key`.\n   *\n   * @param {String} key\n   * @return {Point}\n   */\n\n  setKey(key) {\n    if (key !== null) {\n      key = KeyUtils.create(key)\n    }\n\n    const point = this.set('key', key)\n    return point\n  }\n\n  /**\n   * Set the point's offset to a new `offset`.\n   *\n   * @param {Number} offset\n   * @return {Point}\n   */\n\n  setOffset(offset) {\n    const point = this.set('offset', offset)\n    return point\n  }\n\n  /**\n   * Set the point's path to a new `path`.\n   *\n   * @param {List|Array} path\n   * @return {Point}\n   */\n\n  setPath(path) {\n    if (path !== null) {\n      path = PathUtils.create(path)\n    }\n\n    const point = this.set('path', path)\n    return point\n  }\n\n  /**\n   * Return a JSON representation of the point.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      key: this.key,\n      offset: this.offset,\n      path: this.path && this.path.toArray(),\n    }\n\n    if (!options.preserveKeys) {\n      delete object.key\n    }\n\n    return object\n  }\n\n  /**\n   * Unset the point.\n   *\n   * @return {Point}\n   */\n\n  unset() {\n    return this.merge({\n      key: null,\n      offset: null,\n      path: null,\n    })\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nPoint.prototype[MODEL_TYPES.POINT] = true\n\n/**\n * Export.\n *\n * @type {Point}\n */\n\nexport default Point\n","import isPlainObject from 'is-plain-object'\nimport { List, Record } from 'immutable'\n\nimport Mark from './mark'\nimport MODEL_TYPES from '../constants/model-types'\nimport Point from './point'\nimport Range from './range'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  anchor: Point.create(),\n  focus: Point.create(),\n  mark: undefined,\n}\n\n/**\n * Decoration.\n *\n * @type {Decoration}\n */\n\nclass Decoration extends Record(DEFAULTS) {\n  /**\n   * Create a new `Decoration` with `attrs`.\n   *\n   * @param {Object|Decoration} attrs\n   * @return {Decoration}\n   */\n\n  static create(attrs = {}) {\n    if (Decoration.isDecoration(attrs)) {\n      return attrs\n    }\n\n    if (Range.isRange(attrs)) {\n      return Decoration.fromJSON(Range.createProperties(attrs))\n    }\n\n    if (isPlainObject(attrs)) {\n      return Decoration.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Decoration.create\\` only accepts objects or decorations, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Ranges` from `elements`.\n   *\n   * @param {Array<Decoration|Object>|List<Decoration|Object>} elements\n   * @return {List<Decoration>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Decoration.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Decoration.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable decoration properties from `attrs`.\n   *\n   * @param {Object|String|Decoration} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Decoration.isDecoration(a)) {\n      return {\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n        mark: Mark.create(a.mark),\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('anchor' in a) p.anchor = Point.create(a.anchor)\n      if ('focus' in a) p.focus = Point.create(a.focus)\n      if ('mark' in a) p.mark = Mark.create(a.mark)\n      return p\n    }\n\n    throw new Error(\n      `\\`Decoration.createProperties\\` only accepts objects or decorations, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Decoration` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Decoration}\n   */\n\n  static fromJSON(object) {\n    const { anchor, focus, mark } = object\n    const decoration = new Decoration({\n      anchor: Point.fromJSON(anchor || {}),\n      focus: Point.fromJSON(focus || {}),\n      mark: Mark.fromJSON(mark),\n    })\n\n    return decoration\n  }\n\n  /**\n   * Check if an `obj` is a `Decoration`.\n   *\n   * @param {Any} obj\n   * @return {Boolean}\n   */\n\n  static isDecoration(obj) {\n    return !!(obj && obj[MODEL_TYPES.DECORATION])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'decoration'\n  }\n\n  /**\n   * Set new `properties` on the decoration.\n   *\n   * @param {Object|Range|Selection} properties\n   * @return {Range}\n   */\n\n  setProperties(properties) {\n    properties = Decoration.createProperties(properties)\n    const { anchor, focus, mark } = properties\n    const props = {}\n\n    if (anchor) {\n      props.anchor = Point.create(anchor)\n    }\n\n    if (focus) {\n      props.focus = Point.create(focus)\n    }\n\n    if (mark) {\n      props.mark = Mark.create(mark)\n    }\n\n    const decoration = this.merge(props)\n    return decoration\n  }\n\n  /**\n   * Return a JSON representation of the decoration.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n      mark: this.mark.toJSON(options),\n    }\n\n    return object\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nDecoration.prototype[MODEL_TYPES.DECORATION] = true\n\n/**\n * Export.\n *\n * @type {Decoration}\n */\n\nexport default Decoration\n","import isPlainObject from 'is-plain-object'\nimport { List, Record } from 'immutable'\n\nimport Decoration from './decoration'\nimport MODEL_TYPES from '../constants/model-types'\nimport Point from './point'\nimport Selection from './selection'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  anchor: Point.create(),\n  focus: Point.create(),\n}\n\n/**\n * Range.\n *\n * @type {Range}\n */\n\nclass Range extends Record(DEFAULTS) {\n  /**\n   * Create a new `Range` with `attrs`.\n   *\n   * @param {Object|Range} attrs\n   * @return {Range}\n   */\n\n  static create(attrs = {}) {\n    if (Range.isRange(attrs)) {\n      if (attrs.object === 'range') {\n        return attrs\n      } else {\n        return Range.fromJSON(Range.createProperties(attrs))\n      }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Range.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Range.create\\` only accepts objects or ranges, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Ranges` from `elements`.\n   *\n   * @param {Array<Range|Object>|List<Range|Object>} elements\n   * @return {List<Range>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Range.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Range.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable range properties from `attrs`.\n   *\n   * @param {Object|String|Range} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Range.isRange(a)) {\n      return {\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('anchor' in a) p.anchor = Point.create(a.anchor)\n      if ('focus' in a) p.focus = Point.create(a.focus)\n      return p\n    }\n\n    throw new Error(\n      `\\`Range.createProperties\\` only accepts objects, decorations, ranges or selections, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Range` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Range}\n   */\n\n  static fromJSON(object) {\n    const { anchor, focus } = object\n    const range = new Range({\n      anchor: Point.fromJSON(anchor || {}),\n      focus: Point.fromJSON(focus || {}),\n    })\n\n    return range\n  }\n\n  /**\n   * Check if an `obj` is a `Range`, or is range-like.\n   *\n   * @param {Any} obj\n   * @return {Boolean}\n   */\n\n  static isRange(obj) {\n    return (\n      !!(obj && obj[MODEL_TYPES.RANGE]) ||\n      Decoration.isDecoration(obj) ||\n      Selection.isSelection(obj)\n    )\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'range'\n  }\n\n  /**\n   * Return a JSON representation of the range.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n    }\n\n    return object\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nRange.prototype[MODEL_TYPES.RANGE] = true\n\n/**\n * Export.\n *\n * @type {Range}\n */\n\nexport default Range\n","import isPlainObject from 'is-plain-object'\nimport { Record, Set } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport Mark from './mark'\nimport Point from './point'\nimport Range from './range'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  anchor: Point.create(),\n  focus: Point.create(),\n  isFocused: false,\n  marks: null,\n}\n\n/**\n * Selection.\n *\n * @type {Selection}\n */\n\nclass Selection extends Record(DEFAULTS) {\n  /**\n   * Create a new `Selection` with `attrs`.\n   *\n   * @param {Object|Selection} attrs\n   * @return {Selection}\n   */\n\n  static create(attrs = {}) {\n    if (Selection.isSelection(attrs)) {\n      return attrs\n    }\n\n    if (Range.isRange(attrs)) {\n      return Selection.fromJSON(Range.createProperties(attrs))\n    }\n\n    if (isPlainObject(attrs)) {\n      return Selection.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Selection.create\\` only accepts objects, ranges or selections, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable selection properties from `attrs`.\n   *\n   * @param {Object|String|Selection} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Selection.isSelection(a)) {\n      return {\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n        isFocused: a.isFocused,\n        marks: a.marks,\n      }\n    }\n\n    if (Range.isRange(a)) {\n      return {\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('anchor' in a) p.anchor = Point.create(a.anchor)\n      if ('focus' in a) p.focus = Point.create(a.focus)\n      if ('isFocused' in a) p.isFocused = a.isFocused\n      if ('marks' in a)\n        p.marks = a.marks == null ? null : Mark.createSet(a.marks)\n      return p\n    }\n\n    throw new Error(\n      `\\`Selection.createProperties\\` only accepts objects, ranges or selections, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Selection` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Selection}\n   */\n\n  static fromJSON(object) {\n    const { anchor, focus, isFocused = false, marks = null } = object\n    const selection = new Selection({\n      anchor: Point.fromJSON(anchor || {}),\n      focus: Point.fromJSON(focus || {}),\n      isFocused,\n      marks: marks == null ? null : new Set(marks.map(Mark.fromJSON)),\n    })\n\n    return selection\n  }\n\n  /**\n   * Check if an `obj` is a `Selection`.\n   *\n   * @param {Any} obj\n   * @return {Boolean}\n   */\n\n  static isSelection(obj) {\n    return !!(obj && obj[MODEL_TYPES.SELECTION])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'selection'\n  }\n\n  /**\n   * Check whether the selection is blurred.\n   *\n   * @return {Boolean}\n   */\n\n  get isBlurred() {\n    return !this.isFocused\n  }\n\n  /**\n   * Set the `isFocused` property to a new `value`.\n   *\n   * @param {Boolean} value\n   * @return {Selection}\n   */\n\n  setIsFocused(value) {\n    const selection = this.set('isFocused', value)\n    return selection\n  }\n\n  /**\n   * Set the `marks` property to a new set of `marks`.\n   *\n   * @param {Set} marks\n   * @return {Selection}\n   */\n\n  setMarks(marks) {\n    const selection = this.set('marks', marks)\n    return selection\n  }\n\n  /**\n   * Set new `properties` on the selection.\n   *\n   * @param {Object|Range|Selection} properties\n   * @return {Range}\n   */\n\n  setProperties(properties) {\n    properties = Selection.createProperties(properties)\n    const { anchor, focus, ...props } = properties\n\n    if (anchor) {\n      props.anchor = Point.create(anchor)\n    }\n\n    if (focus) {\n      props.focus = Point.create(focus)\n    }\n\n    const selection = this.merge(props)\n    return selection\n  }\n\n  /**\n   * Return a JSON representation of the selection.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n      isFocused: this.isFocused,\n      marks:\n        this.marks == null ? null : this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    return object\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nSelection.prototype[MODEL_TYPES.SELECTION] = true\n\n/**\n * Export.\n *\n * @type {Selection}\n */\n\nexport default Selection\n","import Debug from 'debug'\nimport isPlainObject from 'is-plain-object'\nimport { List, Record, Stack } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:history')\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  redos: new Stack(),\n  undos: new Stack(),\n}\n\n/**\n * History.\n *\n * @type {History}\n */\n\nclass History extends Record(DEFAULTS) {\n  /**\n   * Create a new `History` with `attrs`.\n   *\n   * @param {Object|History} attrs\n   * @return {History}\n   */\n\n  static create(attrs = {}) {\n    if (History.isHistory(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return History.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`History.create\\` only accepts objects or histories, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Operations` from `operations`.\n   *\n   * @param {Array<Object>|List<Object>} operations\n   * @return {List<Object>}\n   */\n\n  static createOperationsList(operations = []) {\n    if (List.isList(operations)) {\n      return operations\n    }\n\n    if (Array.isArray(operations)) {\n      return new List(operations)\n    }\n\n    throw new Error(\n      `\\`History.createList\\` only accepts arrays or lists, but you passed it: ${operations}`\n    )\n  }\n\n  /**\n   * Create a `History` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {History}\n   */\n\n  static fromJSON(object) {\n    const { redos = [], undos = [] } = object\n\n    const history = new History({\n      redos: new Stack(redos.map(this.createOperationsList)),\n      undos: new Stack(undos.map(this.createOperationsList)),\n    })\n\n    return history\n  }\n\n  /**\n   * Check if `any` is a `History`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isHistory = isType.bind(null, 'HISTORY')\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'history'\n  }\n\n  /**\n   * Save an `operation` into the history.\n   *\n   * @param {Object} operation\n   * @param {Object} options\n   * @return {History}\n   */\n\n  save(operation, options = {}) {\n    let history = this\n    let { undos, redos } = history\n    let { merge, skip } = options\n    const prevBatch = undos.peek()\n    const prevOperation = prevBatch && prevBatch.last()\n\n    if (skip) {\n      return history\n    }\n\n    if (merge == null) {\n      merge = shouldMerge(operation, prevOperation)\n    }\n\n    debug('save', { operation, merge })\n\n    // If the `merge` flag is true, add the operation to the previous batch.\n    if (merge && prevBatch) {\n      const batch = prevBatch.push(operation)\n      undos = undos.pop()\n      undos = undos.push(batch)\n    } else {\n      // Otherwise, create a new batch with the operation.\n      const batch = new List([operation])\n      undos = undos.push(batch)\n    }\n\n    // Constrain the history to 100 entries for memory's sake.\n    if (undos.size > 100) {\n      undos = undos.take(100)\n    }\n\n    // Clear the redos and update the history.\n    redos = redos.clear()\n    history = history.set('undos', undos).set('redos', redos)\n    return history\n  }\n\n  /**\n   * Return a JSON representation of the history.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      redos: this.redos.toJSON(),\n      undos: this.undos.toJSON(),\n    }\n\n    return object\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nHistory.prototype[MODEL_TYPES.HISTORY] = true\n\n/**\n * Check whether to merge a new operation `o` into the previous operation `p`.\n *\n * @param {Object} o\n * @param {Object} p\n * @return {Boolean}\n */\n\nfunction shouldMerge(o, p) {\n  if (!p) return false\n\n  const merge =\n    (o.type == 'set_selection' && p.type == 'set_selection') ||\n    (o.type == 'insert_text' &&\n      p.type == 'insert_text' &&\n      o.offset == p.offset + p.text.length &&\n      o.path.equals(p.path)) ||\n    (o.type == 'remove_text' &&\n      p.type == 'remove_text' &&\n      o.offset + o.text.length == p.offset &&\n      o.path.equals(p.path))\n\n  return merge\n}\n\n/**\n * Export.\n *\n * @type {History}\n */\n\nexport default History\n","import { Record } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport memoize from '../utils/memoize'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  plugins: [],\n}\n\n/**\n * Stack.\n *\n * @type {Stack}\n */\n\nclass Stack extends Record(DEFAULTS) {\n  /**\n   * Constructor.\n   *\n   * @param {Object} attrs\n   */\n\n  static create(attrs = {}) {\n    const { plugins = [] } = attrs\n    const stack = new Stack({ plugins })\n    return stack\n  }\n\n  /**\n   * Check if `any` is a `Stack`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isStack(any) {\n    return !!(any && any[MODEL_TYPES.STACK])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'stack'\n  }\n\n  /**\n   * Get all plugins with `property`.\n   *\n   * @param {String} property\n   * @return {Array}\n   */\n\n  getPluginsWith(property) {\n    return this.plugins.filter(plugin => plugin[property] != null)\n  }\n\n  /**\n   * Iterate the plugins with `property`, returning the first non-null value.\n   *\n   * @param {String} property\n   * @param {Any} ...args\n   */\n\n  find(property, ...args) {\n    const plugins = this.getPluginsWith(property)\n\n    for (const plugin of plugins) {\n      const ret = plugin[property](...args)\n      if (ret != null) return ret\n    }\n  }\n\n  /**\n   * Iterate the plugins with `property`, returning all the non-null values.\n   *\n   * @param {String} property\n   * @param {Any} ...args\n   * @return {Array}\n   */\n\n  map(property, ...args) {\n    const plugins = this.getPluginsWith(property)\n    const array = []\n\n    for (const plugin of plugins) {\n      const ret = plugin[property](...args)\n      if (ret != null) array.push(ret)\n    }\n\n    return array\n  }\n\n  /**\n   * Iterate the plugins with `property`, breaking on any a non-null values.\n   *\n   * @param {String} property\n   * @param {Any} ...args\n   */\n\n  run(property, ...args) {\n    const plugins = this.getPluginsWith(property)\n\n    for (const plugin of plugins) {\n      const ret = plugin[property](...args)\n      if (ret != null) return\n    }\n  }\n\n  /**\n   * Iterate the plugins with `property`, reducing to a set of React children.\n   *\n   * @param {String} property\n   * @param {Object} props\n   * @param {Any} ...args\n   */\n\n  render(property, props, ...args) {\n    const plugins = this.getPluginsWith(property)\n    return plugins.reduceRight((children, plugin) => {\n      if (!plugin[property]) return children\n      const ret = plugin[property](props, ...args)\n      if (ret == null) return children\n      props.children = ret\n      return ret\n    }, props.children === undefined ? null : props.children)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nStack.prototype[MODEL_TYPES.STACK] = true\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Stack.prototype, ['getPluginsWith'])\n\n/**\n * Export.\n *\n * @type {Stack}\n */\n\nexport default Stack\n","/**\n * Define a Slate error.\n *\n * @type {SlateError}\n */\n\nclass SlateError extends Error {\n  constructor(code, attrs = {}) {\n    super(code)\n    this.code = code\n\n    for (const key in attrs) {\n      this[key] = attrs[key]\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    } else {\n      this.stack = new Error().stack\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {SlateError}\n */\n\nexport default SlateError\n","import Debug from 'debug'\nimport isPlainObject from 'is-plain-object'\nimport { Record } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport Stack from './stack'\nimport Text from './text'\nimport SlateError from '../utils/slate-error'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:schema')\n\n/**\n * Define the core schema rules, order-sensitive.\n *\n * @type {Array}\n */\n\nconst CORE_RULES = [\n  // Only allow block nodes in documents.\n  {\n    match: { object: 'document' },\n    nodes: [\n      {\n        match: { object: 'block' },\n      },\n    ],\n  },\n\n  // Only allow block nodes or inline and text nodes in blocks.\n  {\n    match: {\n      object: 'block',\n      first: { object: 'block' },\n    },\n    nodes: [\n      {\n        match: { object: 'block' },\n      },\n    ],\n  },\n  {\n    match: {\n      object: 'block',\n      first: [{ object: 'inline' }, { object: 'text' }],\n    },\n    nodes: [\n      {\n        match: [{ object: 'inline' }, { object: 'text' }],\n      },\n    ],\n  },\n\n  // Only allow inline and text nodes in inlines.\n  {\n    match: { object: 'inline' },\n    nodes: [{ match: [{ object: 'inline' }, { object: 'text' }] }],\n  },\n\n  // Ensure that block and inline nodes have at least one text child.\n  {\n    match: [{ object: 'block' }, { object: 'inline' }],\n    nodes: [{ min: 1 }],\n    normalize: (change, error) => {\n      const { code, node } = error\n      if (code !== 'child_required') return\n      change.insertNodeByKey(node.key, 0, Text.create(), { normalize: false })\n    },\n  },\n\n  // Ensure that inline nodes are surrounded by text nodes.\n  {\n    match: { object: 'block' },\n    first: [{ object: 'block' }, { object: 'text' }],\n    last: [{ object: 'block' }, { object: 'text' }],\n    normalize: (change, error) => {\n      const { code, node } = error\n      const text = Text.create()\n      let i\n\n      if (code === 'first_child_object_invalid') {\n        i = 0\n      } else if (code === 'last_child_object_invalid') {\n        i = node.nodes.size\n      } else {\n        return\n      }\n\n      change.insertNodeByKey(node.key, i, text, { normalize: false })\n    },\n  },\n  {\n    match: { object: 'inline' },\n    first: [{ object: 'block' }, { object: 'text' }],\n    last: [{ object: 'block' }, { object: 'text' }],\n    previous: [{ object: 'block' }, { object: 'text' }],\n    next: [{ object: 'block' }, { object: 'text' }],\n    normalize: (change, error) => {\n      const { code, node, index } = error\n      const text = Text.create()\n      let i\n\n      if (code === 'first_child_object_invalid') {\n        i = 0\n      } else if (code === 'last_child_object_invalid') {\n        i = node.nodes.size\n      } else if (code === 'previous_sibling_object_invalid') {\n        i = index\n      } else if (code === 'next_sibling_object_invalid') {\n        i = index + 1\n      } else {\n        return\n      }\n\n      change.insertNodeByKey(node.key, i, text, { normalize: false })\n    },\n  },\n\n  // Merge adjacent text nodes.\n  {\n    match: { object: 'text' },\n    next: [{ object: 'block' }, { object: 'inline' }],\n    normalize: (change, error) => {\n      const { code, next } = error\n      if (code !== 'next_sibling_object_invalid') return\n      change.mergeNodeByKey(next.key, { normalize: false })\n    },\n  },\n]\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  stack: Stack.create(),\n  rules: [],\n}\n\n/**\n * Schema.\n *\n * @type {Schema}\n */\n\nclass Schema extends Record(DEFAULTS) {\n  /**\n   * Create a new `Schema` with `attrs`.\n   *\n   * @param {Object|Schema} attrs\n   * @return {Schema}\n   */\n\n  static create(attrs = {}) {\n    if (Schema.isSchema(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Schema.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Schema.create\\` only accepts objects or schemas, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Schema` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Schema}\n   */\n\n  static fromJSON(object) {\n    if (Schema.isSchema(object)) {\n      return object\n    }\n\n    const plugins = object.plugins ? object.plugins : [{ schema: object }]\n    let rules = [...CORE_RULES]\n\n    for (const plugin of plugins) {\n      const { schema = {} } = plugin\n      const { blocks = {}, inlines = {}, marks = {} } = schema\n\n      if (schema.rules) {\n        rules = rules.concat(schema.rules)\n      }\n\n      if (schema.document) {\n        rules.push({\n          match: [{ object: 'document' }],\n          ...schema.document,\n        })\n      }\n\n      for (const key in blocks) {\n        rules.push({\n          match: [{ object: 'block', type: key }],\n          ...blocks[key],\n        })\n      }\n\n      for (const key in inlines) {\n        rules.push({\n          match: [{ object: 'inline', type: key }],\n          ...inlines[key],\n        })\n      }\n\n      for (const key in marks) {\n        rules.push({\n          match: [{ object: 'mark', type: key }],\n          ...marks[key],\n        })\n      }\n    }\n\n    const stack = Stack.create({ plugins })\n    const ret = new Schema({ stack, rules })\n    return ret\n  }\n\n  /**\n   * Check if `any` is a `Schema`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isSchema(any) {\n    return !!(any && any[MODEL_TYPES.SCHEMA])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'schema'\n  }\n\n  /**\n   * Get the schema rules for a `node`.\n   *\n   * @param {Node} node\n   * @return {Array}\n   */\n\n  getNodeRules(node) {\n    const rules = this.rules.filter(r => testRules(node, r.match))\n    return rules\n  }\n\n  /**\n   * Validate a `node` with the schema, returning an error if it's invalid.\n   *\n   * @param {Node} node\n   * @return {Error|Void}\n   */\n\n  validateNode(node) {\n    const rules = this.getNodeRules(node)\n    const failure = validateRules(node, rules, this.rules, { every: true })\n    if (!failure) return\n    const error = new SlateError(failure.code, failure)\n    return error\n  }\n\n  /**\n   * Test whether a `node` is valid against the schema.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  testNode(node) {\n    const error = this.validateNode(node)\n    return !error\n  }\n\n  /**\n   * Assert that a `node` is valid against the schema.\n   *\n   * @param {Node} node\n   * @throws\n   */\n\n  assertNode(node) {\n    const error = this.validateNode(node)\n    if (error) throw error\n  }\n\n  /**\n   * Normalize a `node` with the schema, returning a function that will fix the\n   * invalid node, or void if the node is valid.\n   *\n   * @param {Node} node\n   * @return {Function|Void}\n   */\n\n  normalizeNode(node) {\n    const ret = this.stack.find('normalizeNode', node)\n    if (ret) return ret\n    if (node.object == 'text') return\n\n    const error = this.validateNode(node)\n    if (!error) return\n\n    return change => {\n      debug(`normalizing`, { error })\n      const { rule } = error\n      const { size } = change.operations\n\n      // First run the user-provided `normalize` function if one exists...\n      if (rule.normalize) {\n        rule.normalize(change, error)\n      }\n\n      // If the `normalize` function did not add any operations to the change\n      // object, it can't have normalized, so run the default one.\n      if (change.operations.size === size) {\n        defaultNormalize(change, error)\n      }\n    }\n  }\n\n  /**\n   * Check if a mark is void.\n   *\n   * @param {Mark}\n   * @return {Boolean}\n   */\n\n  isAtomic(mark) {\n    const rule = this.rules.find(\n      r => 'isAtomic' in r && testRules(mark, r.match)\n    )\n\n    return rule ? rule.isAtomic : false\n  }\n\n  /**\n   * Check if a node is void.\n   *\n   * @param {Node}\n   * @return {Boolean}\n   */\n\n  isVoid(node) {\n    const rule = this.rules.find(r => 'isVoid' in r && testRules(node, r.match))\n    return rule ? rule.isVoid : false\n  }\n\n  /**\n   * Return a JSON representation of the schema.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      rules: this.rules,\n    }\n\n    return object\n  }\n}\n\n/**\n * Normalize an invalid value with `error` with default remedies.\n *\n * @param {Change} change\n * @param {SlateError} error\n */\n\nfunction defaultNormalize(change, error) {\n  const { code, node, child, key, mark } = error\n\n  switch (code) {\n    case 'child_object_invalid':\n    case 'child_type_invalid':\n    case 'child_unknown':\n    case 'first_child_object_invalid':\n    case 'first_child_type_invalid':\n    case 'last_child_object_invalid':\n    case 'last_child_type_invalid': {\n      return child.object === 'text' &&\n        node.object === 'block' &&\n        node.nodes.size === 1\n        ? change.removeNodeByKey(node.key, { normalize: false })\n        : change.removeNodeByKey(child.key, { normalize: false })\n    }\n\n    case 'child_required':\n    case 'node_text_invalid':\n    case 'parent_object_invalid':\n    case 'parent_type_invalid': {\n      return node.object === 'document'\n        ? node.nodes.forEach(n =>\n            change.removeNodeByKey(n.key, { normalize: false })\n          )\n        : change.removeNodeByKey(node.key, { normalize: false })\n    }\n\n    case 'node_data_invalid': {\n      return node.data.get(key) === undefined && node.object !== 'document'\n        ? change.removeNodeByKey(node.key, { normalize: false })\n        : change.setNodeByKey(\n            node.key,\n            { data: node.data.delete(key) },\n            { normalize: false }\n          )\n    }\n\n    case 'node_mark_invalid': {\n      return node.getTexts().forEach(t =>\n        change.removeMarkByKey(t.key, 0, t.text.length, mark, {\n          normalize: false,\n        })\n      )\n    }\n\n    default: {\n      return change.removeNodeByKey(node.key, { normalize: false })\n    }\n  }\n}\n\n/**\n * Check that an `object` matches one of a set of `rules`.\n *\n * @param {Mixed} object\n * @param {Object|Array} rules\n * @return {Boolean}\n */\n\nfunction testRules(object, rules) {\n  const error = validateRules(object, rules)\n  return !error\n}\n\n/**\n * Validate that a `object` matches a `rule` object or array.\n *\n * @param {Mixed} object\n * @param {Object|Array} rule\n * @param {Array|Void} rules\n * @return {Error|Void}\n */\n\nfunction validateRules(object, rule, rules, options = {}) {\n  const { every = false } = options\n\n  if (Array.isArray(rule)) {\n    const array = rule.length ? rule : [{}]\n    let first\n\n    for (const r of array) {\n      const error = validateRules(object, r, rules)\n      first = first || error\n      if (every && error) return error\n      if (!every && !error) return\n    }\n\n    return first\n  }\n\n  const error =\n    validateObject(object, rule) ||\n    validateType(object, rule) ||\n    validateData(object, rule) ||\n    validateMarks(object, rule) ||\n    validateText(object, rule) ||\n    validateFirst(object, rule) ||\n    validateLast(object, rule) ||\n    validateNodes(object, rule, rules)\n\n  return error\n}\n\nfunction validateObject(node, rule) {\n  if (rule.object == null) return\n  if (rule.object === node.object) return\n  return fail('node_object_invalid', { rule, node })\n}\n\nfunction validateType(node, rule) {\n  if (rule.type == null) return\n  if (rule.type === node.type) return\n  return fail('node_type_invalid', { rule, node })\n}\n\nfunction validateData(node, rule) {\n  if (rule.data == null) return\n  if (node.data == null) return\n\n  for (const key in rule.data) {\n    const fn = rule.data[key]\n    const value = node.data && node.data.get(key)\n    const valid = typeof fn === 'function' ? fn(value) : fn === value\n    if (valid) continue\n    return fail('node_data_invalid', { rule, node, key, value })\n  }\n}\n\nfunction validateMarks(node, rule) {\n  if (rule.marks == null) return\n  const marks = node.getMarks().toArray()\n\n  for (const mark of marks) {\n    const valid = rule.marks.some(def => def.type === mark.type)\n    if (valid) continue\n    return fail('node_mark_invalid', { rule, node, mark })\n  }\n}\n\nfunction validateText(node, rule) {\n  if (rule.text == null) return\n  const { text } = node\n  const valid =\n    typeof rule.text === 'function' ? rule.text(text) : rule.text.test(text)\n  if (valid) return\n  return fail('node_text_invalid', { rule, node, text })\n}\n\nfunction validateFirst(node, rule) {\n  if (rule.first == null) return\n  const first = node.nodes.first()\n  if (!first) return\n  const error = validateRules(first, rule.first)\n  if (!error) return\n  error.rule = rule\n  error.node = node\n  error.child = first\n  error.code = error.code.replace('node_', 'first_child_')\n  return error\n}\n\nfunction validateLast(node, rule) {\n  if (rule.last == null) return\n  const last = node.nodes.last()\n  if (!last) return\n  const error = validateRules(last, rule.last)\n  if (!error) return\n  error.rule = rule\n  error.node = node\n  error.child = last\n  error.code = error.code.replace('node_', 'last_child_')\n  return error\n}\n\nfunction validateNodes(node, rule, rules = []) {\n  if (node.nodes == null) return\n\n  const children = node.nodes.toArray()\n  const defs = rule.nodes != null ? rule.nodes.slice() : []\n  let offset\n  let min\n  let index\n  let def\n  let max\n  let child\n  let previous\n  let next\n\n  function nextDef() {\n    offset = offset == null ? null : 0\n    def = defs.shift()\n    min = def && def.min\n    max = def && def.max\n    return !!def\n  }\n\n  function nextChild() {\n    index = index == null ? 0 : index + 1\n    offset = offset == null ? 0 : offset + 1\n    previous = child\n    child = children[index]\n    next = children[index + 1]\n    if (max != null && offset == max) nextDef()\n    return !!child\n  }\n\n  function rewind() {\n    offset -= 1\n    index -= 1\n  }\n\n  if (rule.nodes != null) {\n    nextDef()\n  }\n\n  while (nextChild()) {\n    const err =\n      validateParent(node, child, rules) ||\n      validatePrevious(node, child, previous, index, rules) ||\n      validateNext(node, child, next, index, rules)\n\n    if (err) return err\n\n    if (rule.nodes != null) {\n      if (!def) {\n        return fail('child_unknown', { rule, node, child, index })\n      }\n\n      if (def.match) {\n        const error = validateRules(child, def.match)\n\n        if (error && offset >= min && nextDef()) {\n          rewind()\n          continue\n        }\n\n        if (error) {\n          error.rule = rule\n          error.node = node\n          error.child = child\n          error.index = index\n          error.code = error.code.replace('node_', 'child_')\n          return error\n        }\n      }\n    }\n  }\n\n  if (rule.nodes != null) {\n    while (min != null) {\n      if (offset < min) {\n        return fail('child_required', { rule, node, index })\n      }\n\n      nextDef()\n    }\n  }\n}\n\nfunction validateParent(node, child, rules) {\n  for (const rule of rules) {\n    if (rule.parent == null) continue\n    if (!testRules(child, rule.match)) continue\n\n    const error = validateRules(node, rule.parent)\n    if (!error) continue\n\n    error.rule = rule\n    error.parent = node\n    error.node = child\n    error.code = error.code.replace('node_', 'parent_')\n    return error\n  }\n}\n\nfunction validatePrevious(node, child, previous, index, rules) {\n  if (!previous) return\n\n  for (const rule of rules) {\n    if (rule.previous == null) continue\n    if (!testRules(child, rule.match)) continue\n\n    const error = validateRules(previous, rule.previous)\n    if (!error) continue\n\n    error.rule = rule\n    error.node = node\n    error.child = child\n    error.index = index\n    error.previous = previous\n    error.code = error.code.replace('node_', 'previous_sibling_')\n    return error\n  }\n}\n\nfunction validateNext(node, child, next, index, rules) {\n  if (!next) return\n\n  for (const rule of rules) {\n    if (rule.next == null) continue\n    if (!testRules(child, rule.match)) continue\n\n    const error = validateRules(next, rule.next)\n    if (!error) continue\n\n    error.rule = rule\n    error.node = node\n    error.child = child\n    error.index = index\n    error.next = next\n    error.code = error.code.replace('node_', 'next_sibling_')\n    return error\n  }\n}\n\n/**\n * Create an interim failure object with `code` and `attrs`.\n *\n * @param {String} code\n * @param {Object} attrs\n * @return {Object}\n */\n\nfunction fail(code, attrs) {\n  return { code, ...attrs }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nSchema.prototype[MODEL_TYPES.SCHEMA] = true\n\n/**\n * Export.\n *\n * @type {Schema}\n */\n\nexport default Schema\n","import isPlainObject from 'is-plain-object'\nimport { Record, Set, List, Map } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport PathUtils from '../utils/path-utils'\nimport Change from './change'\nimport Data from './data'\nimport Decoration from './decoration'\nimport Document from './document'\nimport History from './history'\nimport Selection from './selection'\nimport Schema from './schema'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: Map(),\n  decorations: List(),\n  document: Document.create(),\n  history: History.create(),\n  schema: Schema.create(),\n  selection: Selection.create(),\n}\n\n/**\n * Value.\n *\n * @type {Value}\n */\n\nclass Value extends Record(DEFAULTS) {\n  /**\n   * Create a new `Value` with `attrs`.\n   *\n   * @param {Object|Value} attrs\n   * @param {Object} options\n   * @return {Value}\n   */\n\n  static create(attrs = {}, options = {}) {\n    if (Value.isValue(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Value.fromJSON(attrs, options)\n    }\n\n    throw new Error(\n      `\\`Value.create\\` only accepts objects or values, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable value properties from `attrs`.\n   *\n   * @param {Object|Value} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Value.isValue(a)) {\n      return {\n        data: a.data,\n        decorations: a.decorations,\n        schema: a.schema,\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('data' in a) p.data = Data.create(a.data)\n      if ('decorations' in a)\n        p.decorations = Decoration.createList(a.decorations)\n      if ('schema' in a) p.schema = Schema.create(a.schema)\n      return p\n    }\n\n    throw new Error(\n      `\\`Value.createProperties\\` only accepts objects or values, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Value` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @param {Object} options\n   *   @property {Boolean} normalize\n   *   @property {Array} plugins\n   * @return {Value}\n   */\n\n  static fromJSON(object, options = {}) {\n    let {\n      data = {},\n      document = {},\n      selection = {},\n      schema = {},\n      history = {},\n    } = object\n\n    data = Data.fromJSON(data)\n    schema = Schema.fromJSON(schema)\n    history = History.fromJSON(history)\n    document = Document.fromJSON(document)\n    selection = document.createSelection(selection)\n\n    if (selection.isUnset) {\n      const text = document.getFirstText()\n      if (text) selection = selection.moveToStartOfNode(text)\n      selection = document.createSelection(selection)\n    }\n\n    let value = new Value({\n      data,\n      document,\n      selection,\n      schema,\n      history,\n    })\n\n    if (options.normalize !== false) {\n      value = value.change({ save: false }).normalize().value\n    }\n\n    return value\n  }\n\n  /**\n   * Check if a `value` is a `Value`.\n   *\n   * @param {Any} value\n   * @return {Boolean}\n   */\n\n  static isValue(value) {\n    return !!(value && value[MODEL_TYPES.VALUE])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'value'\n  }\n\n  /**\n   * Get the current start text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get startBlock() {\n    return (\n      this.selection.start.key &&\n      this.document.getClosestBlock(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the current end text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get endBlock() {\n    return (\n      this.selection.end.key &&\n      this.document.getClosestBlock(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the current anchor text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get anchorBlock() {\n    return (\n      this.selection.anchor.key &&\n      this.document.getClosestBlock(this.selection.anchor.key)\n    )\n  }\n\n  /**\n   * Get the current focus text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get focusBlock() {\n    return (\n      this.selection.focus.key &&\n      this.document.getClosestBlock(this.selection.focus.key)\n    )\n  }\n\n  /**\n   * Get the current start text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get startInline() {\n    return (\n      this.selection.start.key &&\n      this.document.getClosestInline(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the current end text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get endInline() {\n    return (\n      this.selection.end.key &&\n      this.document.getClosestInline(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the current anchor text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get anchorInline() {\n    return (\n      this.selection.anchor.key &&\n      this.document.getClosestInline(this.selection.anchor.key)\n    )\n  }\n\n  /**\n   * Get the current focus text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get focusInline() {\n    return (\n      this.selection.focus.key &&\n      this.document.getClosestInline(this.selection.focus.key)\n    )\n  }\n\n  /**\n   * Get the current start text node.\n   *\n   * @return {Text}\n   */\n\n  get startText() {\n    return (\n      this.selection.start.key &&\n      this.document.getDescendant(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the current end node.\n   *\n   * @return {Text}\n   */\n\n  get endText() {\n    return (\n      this.selection.end.key &&\n      this.document.getDescendant(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the current anchor node.\n   *\n   * @return {Text}\n   */\n\n  get anchorText() {\n    return (\n      this.selection.anchor.key &&\n      this.document.getDescendant(this.selection.anchor.key)\n    )\n  }\n\n  /**\n   * Get the current focus node.\n   *\n   * @return {Text}\n   */\n\n  get focusText() {\n    return (\n      this.selection.focus.key &&\n      this.document.getDescendant(this.selection.focus.key)\n    )\n  }\n\n  /**\n   * Get the next block node.\n   *\n   * @return {Block}\n   */\n\n  get nextBlock() {\n    return (\n      this.selection.end.key &&\n      this.document.getNextBlock(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the previous block node.\n   *\n   * @return {Block}\n   */\n\n  get previousBlock() {\n    return (\n      this.selection.start.key &&\n      this.document.getPreviousBlock(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the next inline node.\n   *\n   * @return {Inline}\n   */\n\n  get nextInline() {\n    return (\n      this.selection.end.key &&\n      this.document.getNextInline(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the previous inline node.\n   *\n   * @return {Inline}\n   */\n\n  get previousInline() {\n    return (\n      this.selection.start.key &&\n      this.document.getPreviousInline(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the next text node.\n   *\n   * @return {Text}\n   */\n\n  get nextText() {\n    return (\n      this.selection.end.key &&\n      this.document.getNextText(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the previous text node.\n   *\n   * @return {Text}\n   */\n\n  get previousText() {\n    return (\n      this.selection.start.key &&\n      this.document.getPreviousText(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the marks of the current selection.\n   *\n   * @return {Set<Mark>}\n   */\n\n  get marks() {\n    return this.selection.isUnset\n      ? new Set()\n      : this.selection.marks || this.document.getMarksAtRange(this.selection)\n  }\n\n  /**\n   * Get the active marks of the current selection.\n   *\n   * @return {Set<Mark>}\n   */\n\n  get activeMarks() {\n    return this.selection.isUnset\n      ? new Set()\n      : this.selection.marks ||\n          this.document.getActiveMarksAtRange(this.selection)\n  }\n\n  /**\n   * Get the block nodes in the current selection.\n   *\n   * @return {List<Block>}\n   */\n\n  get blocks() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getBlocksAtRange(this.selection)\n  }\n\n  /**\n   * Get the fragment of the current selection.\n   *\n   * @return {Document}\n   */\n\n  get fragment() {\n    return this.selection.isUnset\n      ? Document.create()\n      : this.document.getFragmentAtRange(this.selection)\n  }\n\n  /**\n   * Get the inline nodes in the current selection.\n   *\n   * @return {List<Inline>}\n   */\n\n  get inlines() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getInlinesAtRange(this.selection)\n  }\n\n  /**\n   * Get the text nodes in the current selection.\n   *\n   * @return {List<Text>}\n   */\n\n  get texts() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getTextsAtRange(this.selection)\n  }\n\n  /**\n   * Create a new `Change` with the current value as a starting point.\n   *\n   * @param {Object} attrs\n   * @return {Change}\n   */\n\n  change(attrs = {}) {\n    return new Change({ ...attrs, value: this })\n  }\n\n  /**\n   * Add mark to text at `offset` and `length` in node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Value}\n   */\n\n  addMark(path, offset, length, mark) {\n    let value = this\n    let { document } = value\n    document = document.addMark(path, offset, length, mark)\n    value = this.set('document', document)\n    return value\n  }\n\n  /**\n   * Insert a `node`.\n   *\n   * @param {List|String} path\n   * @param {Node} node\n   * @return {Value}\n   */\n\n  insertNode(path, node) {\n    let value = this\n    let { document } = value\n    document = document.insertNode(path, node)\n    value = value.set('document', document)\n\n    value = value.mapRanges(range =>\n      range.updatePoints(point => point.setPath(null))\n    )\n\n    return value\n  }\n\n  /**\n   * Insert `text` at `offset` in node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {String} text\n   * @param {Set} marks\n   * @return {Value}\n   */\n\n  insertText(path, offset, text, marks) {\n    let value = this\n    let { document, schema } = value\n    document = document.insertText(path, offset, text, marks)\n    value = value.set('document', document)\n\n    // Update any ranges that were affected.\n    const node = document.assertNode(path)\n\n    value = value.mapRanges(range => {\n      const { anchor, focus, isBackward } = range\n      const isAtomic =\n        Decoration.isDecoration(range) && schema.isAtomic(range.mark)\n\n      if (\n        anchor.key === node.key &&\n        (anchor.offset > offset ||\n          (anchor.offset === offset && (!isAtomic || !isBackward)))\n      ) {\n        range = range.moveAnchorForward(text.length)\n      }\n\n      if (\n        focus.key === node.key &&\n        (focus.offset > offset ||\n          (focus.offset == offset && (!isAtomic || isBackward)))\n      ) {\n        range = range.moveFocusForward(text.length)\n      }\n\n      return range\n    })\n\n    value = value.clearAtomicRanges(node.key, offset)\n    return value\n  }\n\n  /**\n   * Merge a node backwards its previous sibling.\n   *\n   * @param {List|Key} path\n   * @return {Value}\n   */\n\n  mergeNode(path) {\n    let value = this\n    const { document } = value\n    const newDocument = document.mergeNode(path)\n    path = document.resolvePath(path)\n    const withPath = PathUtils.decrement(path)\n    const one = document.getNode(withPath)\n    const two = document.getNode(path)\n    value = value.set('document', newDocument)\n\n    value = value.mapRanges(range => {\n      if (two.object === 'text') {\n        const max = one.text.length\n\n        if (range.anchor.key === two.key) {\n          range = range.moveAnchorTo(one.key, max + range.anchor.offset)\n        }\n\n        if (range.focus.key === two.key) {\n          range = range.moveFocusTo(one.key, max + range.focus.offset)\n        }\n      }\n\n      range = range.updatePoints(point => point.setPath(null))\n\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Move a node by `path` to `newPath`.\n   *\n   * A `newIndex` can be provided when move nodes by `key`, to account for not\n   * being able to have a key for a location in the tree that doesn't exist yet.\n   *\n   * @param {List|Key} path\n   * @param {List|Key} newPath\n   * @param {Number} newIndex\n   * @return {Value}\n   */\n\n  moveNode(path, newPath, newIndex = 0) {\n    let value = this\n    let { document } = value\n    document = document.moveNode(path, newPath, newIndex)\n    value = value.set('document', document)\n\n    value = value.mapRanges(range =>\n      range.updatePoints(point => point.setPath(null))\n    )\n\n    return value\n  }\n\n  /**\n   * Remove mark from text at `offset` and `length` in node.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Value}\n   */\n\n  removeMark(path, offset, length, mark) {\n    let value = this\n    let { document } = value\n    document = document.removeMark(path, offset, length, mark)\n    value = this.set('document', document)\n    return value\n  }\n\n  /**\n   * Remove a node by `path`.\n   *\n   * @param {List|String} path\n   * @return {Value}\n   */\n\n  removeNode(path) {\n    let value = this\n    let { document } = value\n    const node = document.assertNode(path)\n    const first = node.object == 'text' ? node : node.getFirstText() || node\n    const last = node.object == 'text' ? node : node.getLastText() || node\n    const prev = document.getPreviousText(first.key)\n    const next = document.getNextText(last.key)\n\n    document = document.removeNode(path)\n    value = value.set('document', document)\n\n    value = value.mapRanges(range => {\n      const { start, end } = range\n\n      if (node.hasNode(start.key)) {\n        range = prev\n          ? range.moveStartTo(prev.key, prev.text.length)\n          : next ? range.moveStartTo(next.key, 0) : range.unset()\n      }\n\n      if (node.hasNode(end.key)) {\n        range = prev\n          ? range.moveEndTo(prev.key, prev.text.length)\n          : next ? range.moveEndTo(next.key, 0) : range.unset()\n      }\n\n      range = range.updatePoints(point => point.setPath(null))\n\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Remove `text` at `offset` in node by `path`.\n   *\n   * @param {List|Key} path\n   * @param {Number} offset\n   * @param {String} text\n   * @return {Value}\n   */\n\n  removeText(path, offset, text) {\n    let value = this\n    let { document } = value\n    document = document.removeText(path, offset, text)\n    value = value.set('document', document)\n\n    const node = document.assertNode(path)\n    const { length } = text\n    const rangeOffset = offset + length\n\n    value = value.clearAtomicRanges(node.key, offset, offset + length)\n\n    value = value.mapRanges(range => {\n      const { anchor, focus } = range\n\n      if (anchor.key === node.key) {\n        range =\n          anchor.offset >= rangeOffset\n            ? range.moveAnchorBackward(length)\n            : anchor.offset > offset\n              ? range.moveAnchorTo(anchor.key, offset)\n              : range\n      }\n\n      if (focus.key === node.key) {\n        range =\n          focus.offset >= rangeOffset\n            ? range.moveFocusBackward(length)\n            : focus.offset > offset\n              ? range.moveFocusTo(focus.key, offset)\n              : range\n      }\n\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Set `properties` on a node.\n   *\n   * @param {List|String} path\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  setNode(path, properties) {\n    let value = this\n    let { document } = value\n    document = document.setNode(path, properties)\n    value = value.set('document', document)\n    return value\n  }\n\n  /**\n   * Set `properties` on `mark` on text at `offset` and `length` in node.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {Number} length\n   * @param {Mark} mark\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  setMark(path, offset, length, mark, properties) {\n    let value = this\n    let { document } = value\n    document = document.setMark(path, offset, length, mark, properties)\n    value = value.set('document', document)\n    return value\n  }\n\n  /**\n   * Set `properties` on the value.\n   *\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  setProperties(properties) {\n    let value = this\n    const { document } = value\n    const { data, decorations, history, schema } = properties\n    const props = {}\n\n    if (data) {\n      props.data = data\n    }\n\n    if (history) {\n      props.history = history\n    }\n\n    if (schema) {\n      props.schema = schema\n    }\n\n    if (decorations) {\n      props.decorations = decorations.map(d => {\n        return d.isSet ? d : document.resolveDecoration(d)\n      })\n    }\n\n    value = value.merge(props)\n    return value\n  }\n\n  /**\n   * Set `properties` on the selection.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  setSelection(properties) {\n    let value = this\n    let { document, selection } = value\n    const next = selection.setProperties(properties)\n    selection = document.resolveSelection(next)\n    value = value.set('selection', selection)\n    return value\n  }\n\n  /**\n   * Split a node by `path` at `position` with optional `properties` to apply\n   * to the newly split node.\n   *\n   * @param {List|String} path\n   * @param {Number} position\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  splitNode(path, position, properties) {\n    let value = this\n    const { document } = value\n    const newDocument = document.splitNode(path, position, properties)\n    const node = document.assertNode(path)\n    value = value.set('document', newDocument)\n\n    value = value.mapRanges(range => {\n      const next = newDocument.getNextText(node.key)\n      const { start, end } = range\n\n      // If the start was after the split, move it to the next node.\n      if (node.key === start.key && position <= start.offset) {\n        range = range.moveStartTo(next.key, start.offset - position)\n      }\n\n      // If the end was after the split, move it to the next node.\n      if (node.key === end.key && position <= end.offset) {\n        range = range.moveEndTo(next.key, end.offset - position)\n      }\n\n      range = range.updatePoints(point => point.setPath(null))\n\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Map all range objects to apply adjustments with an `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {Value}\n   */\n\n  mapRanges(iterator) {\n    let value = this\n    const { document, selection, decorations } = value\n\n    let sel = selection.isSet ? iterator(selection) : selection\n    if (!sel) sel = selection.unset()\n    if (sel !== selection) sel = document.createSelection(sel)\n    value = value.set('selection', sel)\n\n    let decs = decorations.map(decoration => {\n      let n = decoration.isSet ? iterator(decoration) : decoration\n      if (n && n !== decoration) n = document.createDecoration(n)\n      return n\n    })\n\n    decs = decs.filter(decoration => !!decoration)\n    value = value.set('decorations', decs)\n    return value\n  }\n\n  /**\n   * Remove any atomic ranges inside a `key`, `offset` and `length`.\n   *\n   * @param {String} key\n   * @param {Number} from\n   * @param {Number?} to\n   * @return {Value}\n   */\n\n  clearAtomicRanges(key, from, to = null) {\n    let value = this\n    const { schema } = value\n\n    value = this.mapRanges(range => {\n      if (!Decoration.isDecoration(range)) return range\n      const { start, end, mark } = range\n      const isAtomic = schema.isAtomic(mark)\n      if (!isAtomic) return range\n      if (start.key !== key) return range\n\n      if (start.offset < from && (end.key !== key || end.offset > from)) {\n        return null\n      }\n\n      if (\n        to != null &&\n        start.offset < to &&\n        (end.key !== key || end.offset > to)\n      ) {\n        return null\n      }\n\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Return a JSON representation of the value.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      document: this.document.toJSON(options),\n    }\n\n    if (options.preserveData) {\n      object.data = this.data.toJSON(options)\n    }\n\n    if (options.preserveDecorations) {\n      object.decorations = this.decorations\n        .toArray()\n        .map(d => d.toJSON(options))\n    }\n\n    if (options.preserveHistory) {\n      object.history = this.history.toJSON(options)\n    }\n\n    if (options.preserveSelection) {\n      object.selection = this.selection.toJSON(options)\n    }\n\n    if (options.preserveSchema) {\n      object.schema = this.schema.toJSON(options)\n    }\n\n    return object\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nValue.prototype[MODEL_TYPES.VALUE] = true\n\n/**\n * Export.\n */\n\nexport default Value\n","import isPlainObject from 'is-plain-object'\nimport { List, Record } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport Mark from './mark'\nimport Node from './node'\nimport PathUtils from '../utils/path-utils'\nimport Selection from './selection'\nimport Value from './value'\n\n/**\n * Operation attributes.\n *\n * @type {Array}\n */\n\nconst OPERATION_ATTRIBUTES = {\n  add_mark: ['value', 'path', 'offset', 'length', 'mark'],\n  insert_node: ['value', 'path', 'node'],\n  insert_text: ['value', 'path', 'offset', 'text', 'marks'],\n  merge_node: ['value', 'path', 'position', 'properties', 'target'],\n  move_node: ['value', 'path', 'newPath'],\n  remove_mark: ['value', 'path', 'offset', 'length', 'mark'],\n  remove_node: ['value', 'path', 'node'],\n  remove_text: ['value', 'path', 'offset', 'text', 'marks'],\n  set_mark: ['value', 'path', 'offset', 'length', 'mark', 'properties'],\n  set_node: ['value', 'path', 'node', 'properties'],\n  set_selection: ['value', 'selection', 'properties'],\n  set_value: ['value', 'properties'],\n  split_node: ['value', 'path', 'position', 'properties', 'target'],\n}\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  length: undefined,\n  mark: undefined,\n  marks: undefined,\n  newPath: undefined,\n  node: undefined,\n  offset: undefined,\n  path: undefined,\n  position: undefined,\n  properties: undefined,\n  selection: undefined,\n  target: undefined,\n  text: undefined,\n  type: undefined,\n  value: undefined,\n}\n\n/**\n * Operation.\n *\n * @type {Operation}\n */\n\nclass Operation extends Record(DEFAULTS) {\n  /**\n   * Create a new `Operation` with `attrs`.\n   *\n   * @param {Object|Array|List|String|Operation} attrs\n   * @return {Operation}\n   */\n\n  static create(attrs = {}) {\n    if (Operation.isOperation(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Operation.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Operation.create\\` only accepts objects or operations, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Operations` from `elements`.\n   *\n   * @param {Array<Operation|Object>|List<Operation|Object>} elements\n   * @return {List<Operation>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Operation.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Operation.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Operation` from a JSON `object`.\n   *\n   * @param {Object|Operation} object\n   * @return {Operation}\n   */\n\n  static fromJSON(object) {\n    if (Operation.isOperation(object)) {\n      return object\n    }\n\n    const { type } = object\n    const ATTRIBUTES = OPERATION_ATTRIBUTES[type]\n    const attrs = { type }\n\n    if (!ATTRIBUTES) {\n      throw new Error(\n        `\\`Operation.fromJSON\\` was passed an unrecognized operation type: \"${type}\"`\n      )\n    }\n\n    for (const key of ATTRIBUTES) {\n      let v = object[key]\n\n      if (v === undefined) {\n        // Skip keys for objects that should not be serialized, and are only used\n        // for providing the local-only invert behavior for the history stack.\n        if (key == 'document') continue\n        if (key == 'selection') continue\n        if (key == 'value') continue\n        if (key == 'node' && type != 'insert_node') continue\n\n        throw new Error(\n          `\\`Operation.fromJSON\\` was passed a \"${type}\" operation without the required \"${key}\" attribute.`\n        )\n      }\n\n      if (key === 'path' || key === 'newPath') {\n        v = PathUtils.create(v)\n      }\n\n      if (key === 'mark') {\n        v = Mark.create(v)\n      }\n\n      if (key === 'marks' && v != null) {\n        v = Mark.createSet(v)\n      }\n\n      if (key === 'node') {\n        v = Node.create(v)\n      }\n\n      if (key === 'selection') {\n        v = Selection.create(v)\n      }\n\n      if (key === 'value') {\n        v = Value.create(v)\n      }\n\n      if (key === 'properties' && type === 'merge_node') {\n        v = Node.createProperties(v)\n      }\n\n      if (key === 'properties' && type === 'set_mark') {\n        v = Mark.createProperties(v)\n      }\n\n      if (key === 'properties' && type === 'set_node') {\n        v = Node.createProperties(v)\n      }\n\n      if (key === 'properties' && type === 'set_selection') {\n        v = Selection.createProperties(v)\n      }\n\n      if (key === 'properties' && type === 'set_value') {\n        v = Value.createProperties(v)\n      }\n\n      if (key === 'properties' && type === 'split_node') {\n        v = Node.createProperties(v)\n      }\n\n      attrs[key] = v\n    }\n\n    const node = new Operation(attrs)\n    return node\n  }\n\n  /**\n   * Check if `any` is a `Operation`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isOperation(any) {\n    return !!(any && any[MODEL_TYPES.OPERATION])\n  }\n\n  /**\n   * Check if `any` is a list of operations.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isOperationList(any) {\n    return List.isList(any) && any.every(item => Operation.isOperation(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'operation'\n  }\n\n  /**\n   * Return a JSON representation of the operation.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const { object, type } = this\n    const json = { object, type }\n    const ATTRIBUTES = OPERATION_ATTRIBUTES[type]\n\n    for (const key of ATTRIBUTES) {\n      let value = this[key]\n\n      // Skip keys for objects that should not be serialized, and are only used\n      // for providing the local-only invert behavior for the history stack.\n      if (key == 'document') continue\n      if (key == 'selection') continue\n      if (key == 'value') continue\n      if (key == 'node' && type != 'insert_node') continue\n\n      if (key == 'mark' || key == 'marks' || key == 'node') {\n        value = value.toJSON()\n      }\n\n      if (key == 'properties' && type == 'merge_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_mark') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_selection') {\n        const v = {}\n        if ('anchor' in value) v.anchor = value.anchor.toJSON()\n        if ('focus' in value) v.focus = value.focus.toJSON()\n        if ('isFocused' in value) v.isFocused = value.isFocused\n        if ('marks' in value) v.marks = value.marks && value.marks.toJSON()\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_value') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('decorations' in value) v.decorations = value.decorations.toJS()\n        if ('schema' in value) v.schema = value.schema.toJS()\n        value = v\n      }\n\n      if (key == 'properties' && type == 'split_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      json[key] = value\n    }\n\n    return json\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nOperation.prototype[MODEL_TYPES.OPERATION] = true\n\n/**\n * Export.\n *\n * @type {Operation}\n */\n\nexport default Operation\n","import Debug from 'debug'\nimport pick from 'lodash/pick'\n\nimport Operation from '../models/operation'\nimport PathUtils from '../utils/path-utils'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:operation:invert')\n\n/**\n * Invert an `op`.\n *\n * @param {Object} op\n * @return {Object}\n */\n\nfunction invertOperation(op) {\n  op = Operation.create(op)\n  const { type } = op\n  debug(type, op)\n\n  switch (type) {\n    case 'insert_node': {\n      const inverse = op.set('type', 'remove_node')\n      return inverse\n    }\n\n    case 'remove_node': {\n      const inverse = op.set('type', 'insert_node')\n      return inverse\n    }\n\n    case 'move_node': {\n      const { newPath, path } = op\n      let inversePath = newPath\n      let inverseNewPath = path\n\n      const pathLast = path.size - 1\n      const newPathLast = newPath.size - 1\n\n      // If the node's old position was a left sibling of an ancestor of\n      // its new position, we need to adjust part of the path by -1.\n      if (\n        path.size < inversePath.size &&\n        path.slice(0, pathLast).every((e, i) => e == inversePath.get(i)) &&\n        path.last() < inversePath.get(pathLast)\n      ) {\n        inversePath = inversePath\n          .slice(0, pathLast)\n          .concat(inversePath.get(pathLast) - 1)\n          .concat(inversePath.slice(pathLast + 1, inversePath.size))\n      }\n\n      // If the node's new position is an ancestor of the old position,\n      // or a left sibling of an ancestor of its old position, we need\n      // to adjust part of the path by 1.\n      if (\n        newPath.size < inverseNewPath.size &&\n        newPath\n          .slice(0, newPathLast)\n          .every((e, i) => e == inverseNewPath.get(i)) &&\n        newPath.last() <= inverseNewPath.get(newPathLast)\n      ) {\n        inverseNewPath = inverseNewPath\n          .slice(0, newPathLast)\n          .concat(inverseNewPath.get(newPathLast) + 1)\n          .concat(inverseNewPath.slice(newPathLast + 1, inverseNewPath.size))\n      }\n\n      const inverse = op.set('path', inversePath).set('newPath', inverseNewPath)\n      return inverse\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const inversePath = PathUtils.decrement(path)\n      const inverse = op.set('type', 'split_node').set('path', inversePath)\n      return inverse\n    }\n\n    case 'split_node': {\n      const { path } = op\n      const inversePath = PathUtils.increment(path)\n      const inverse = op.set('type', 'merge_node').set('path', inversePath)\n      return inverse\n    }\n\n    case 'set_node': {\n      const { properties, node } = op\n      const inverseNode = node.merge(properties)\n      const inverseProperties = pick(node, Object.keys(properties))\n      const inverse = op\n        .set('node', inverseNode)\n        .set('properties', inverseProperties)\n      return inverse\n    }\n\n    case 'insert_text': {\n      const inverse = op.set('type', 'remove_text')\n      return inverse\n    }\n\n    case 'remove_text': {\n      const inverse = op.set('type', 'insert_text')\n      return inverse\n    }\n\n    case 'add_mark': {\n      const inverse = op.set('type', 'remove_mark')\n      return inverse\n    }\n\n    case 'remove_mark': {\n      const inverse = op.set('type', 'add_mark')\n      return inverse\n    }\n\n    case 'set_mark': {\n      const { properties, mark } = op\n      const inverseMark = mark.merge(properties)\n      const inverseProperties = pick(mark, Object.keys(properties))\n      const inverse = op\n        .set('mark', inverseMark)\n        .set('properties', inverseProperties)\n      return inverse\n    }\n\n    case 'set_selection': {\n      const { properties, selection } = op\n      const inverseSelection = selection.merge(properties)\n      const inverseProps = pick(selection, Object.keys(properties))\n      const inverse = op\n        .set('selection', inverseSelection)\n        .set('properties', inverseProps)\n      return inverse\n    }\n\n    case 'set_value': {\n      const { properties, value } = op\n      const inverseValue = value.merge(properties)\n      const inverseProperties = pick(value, Object.keys(properties))\n      const inverse = op\n        .set('value', inverseValue)\n        .set('properties', inverseProperties)\n      return inverse\n    }\n\n    default: {\n      throw new Error(`Unknown operation type: \"${type}\".`)\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default invertOperation\n","import invert from '../operations/invert'\nimport omit from 'lodash/omit'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Redo to the next value in the history.\n *\n * @param {Change} change\n */\n\nChanges.redo = change => {\n  let { value } = change\n  let { history } = value\n  if (!history) return\n\n  let { undos, redos } = history\n  const next = redos.peek()\n  if (!next) return\n\n  // Shift the next value into the undo stack.\n  redos = redos.pop()\n  undos = undos.push(next)\n\n  // Replay the next operations.\n  next.forEach(op => {\n    const { type, properties } = op\n\n    // When the operation mutates the selection, omit its `isFocused` value to\n    // prevent the editor focus from changing during redoing.\n    if (type == 'set_selection') {\n      op = op.set('properties', omit(properties, 'isFocused'))\n    }\n\n    change.applyOperation(op, { save: false })\n  })\n\n  // Update the history.\n  value = change.value\n  history = history.set('undos', undos).set('redos', redos)\n  value = value.set('history', history)\n  change.value = value\n}\n\n/**\n * Undo the previous operations in the history.\n *\n * @param {Change} change\n */\n\nChanges.undo = change => {\n  let { value } = change\n  let { history } = value\n  if (!history) return\n\n  let { undos, redos } = history\n  const previous = undos.peek()\n  if (!previous) return\n\n  // Shift the previous operations into the redo stack.\n  undos = undos.pop()\n  redos = redos.push(previous)\n\n  // Replay the inverse of the previous operations.\n  previous\n    .slice()\n    .reverse()\n    .map(invert)\n    .forEach(inverse => {\n      const { type, properties } = inverse\n\n      // When the operation mutates the selection, omit its `isFocused` value to\n      // prevent the editor focus from changing during undoing.\n      if (type == 'set_selection') {\n        inverse = inverse.set('properties', omit(properties, 'isFocused'))\n      }\n\n      change.applyOperation(inverse, { save: false })\n    })\n\n  // Update the history.\n  value = change.value\n  history = history.set('undos', undos).set('redos', redos)\n  value = value.set('history', history)\n  change.value = value\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import { is } from 'immutable'\nimport pick from 'lodash/pick'\n\nimport Selection from '../models/selection'\n\nconst Changes = {}\n\nChanges.blur = change => {\n  change.select({ isFocused: false })\n}\n\nChanges.deselect = change => {\n  const range = Selection.create()\n  change.select(range)\n}\n\nChanges.focus = change => {\n  change.select({ isFocused: true })\n}\n\nChanges.flip = change => {\n  change.call(proxy, 'flip')\n}\n\nChanges.moveAnchorBackward = (change, ...args) => {\n  change.call(pointBackward, 'anchor', ...args)\n}\n\nChanges.moveAnchorForward = (change, ...args) => {\n  change.call(pointForward, 'anchor', ...args)\n}\n\nChanges.moveAnchorTo = (change, ...args) => {\n  change.call(proxy, 'moveAnchorTo', ...args)\n}\n\nChanges.moveAnchorToEndOfBlock = change => {\n  change.call(pointEdgeObject, 'anchor', 'end', 'block')\n}\n\nChanges.moveAnchorToEndOfInline = change => {\n  change.call(pointEdgeObject, 'anchor', 'end', 'inline')\n}\n\nChanges.moveAnchorToEndOfDocument = change => {\n  change.moveAnchorToEndOfNode(change.value.document).moveToAnchor()\n}\n\nChanges.moveAnchorToEndOfNextBlock = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'end', 'next', 'block')\n}\n\nChanges.moveAnchorToEndOfNextInline = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'end', 'next', 'inline')\n}\n\nChanges.moveAnchorToEndOfNextText = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'end', 'next', 'text')\n}\n\nChanges.moveAnchorToEndOfNode = (change, ...args) => {\n  change.call(proxy, 'moveAnchorToEndOfNode', ...args)\n}\n\nChanges.moveAnchorToEndOfPreviousBlock = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'end', 'previous', 'block')\n}\n\nChanges.moveAnchorToEndOfPreviousInline = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'end', 'previous', 'inline')\n}\n\nChanges.moveAnchorToEndOfPreviousText = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'end', 'previous', 'text')\n}\n\nChanges.moveAnchorToEndOfText = change => {\n  change.call(pointEdgeObject, 'anchor', 'end', 'text')\n}\n\nChanges.moveAnchorToStartOfBlock = change => {\n  change.call(pointEdgeObject, 'anchor', 'start', 'block')\n}\n\nChanges.moveAnchorToStartOfDocument = change => {\n  change.moveAnchorToStartOfNode(change.value.document).moveToAnchor()\n}\n\nChanges.moveAnchorToStartOfInline = change => {\n  change.call(pointEdgeObject, 'anchor', 'start', 'inline')\n}\n\nChanges.moveAnchorToStartOfNextBlock = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'start', 'next', 'block')\n}\n\nChanges.moveAnchorToStartOfNextInline = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'start', 'next', 'inline')\n}\n\nChanges.moveAnchorToStartOfNextText = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'start', 'next', 'text')\n}\n\nChanges.moveAnchorToStartOfNode = (change, ...args) => {\n  change.call(proxy, 'moveAnchorToStartOfNode', ...args)\n}\n\nChanges.moveAnchorToStartOfPreviousBlock = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'start', 'previous', 'block')\n}\n\nChanges.moveAnchorToStartOfPreviousInline = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'start', 'previous', 'inline')\n}\n\nChanges.moveAnchorToStartOfPreviousText = change => {\n  change.call(pointEdgeSideObject, 'anchor', 'start', 'previous', 'text')\n}\n\nChanges.moveAnchorToStartOfText = change => {\n  change.call(pointEdgeObject, 'anchor', 'start', 'text')\n}\n\nChanges.moveBackward = (change, ...args) => {\n  change.moveAnchorBackward(...args).moveFocusBackward(...args)\n}\n\nChanges.moveEndBackward = (change, ...args) => {\n  change.call(pointBackward, 'end', ...args)\n}\n\nChanges.moveEndForward = (change, ...args) => {\n  change.call(pointForward, 'end', ...args)\n}\n\nChanges.moveEndTo = (change, ...args) => {\n  change.call(proxy, 'moveEndTo', ...args)\n}\n\nChanges.moveEndToEndOfBlock = change => {\n  change.call(pointEdgeObject, 'end', 'end', 'block')\n}\n\nChanges.moveEndToEndOfDocument = change => {\n  change.moveEndToEndOfNode(change.value.document).moveToEnd()\n}\n\nChanges.moveEndToEndOfInline = change => {\n  change.call(pointEdgeObject, 'end', 'end', 'inline')\n}\n\nChanges.moveEndToEndOfNextBlock = change => {\n  change.call(pointEdgeSideObject, 'end', 'end', 'next', 'block')\n}\n\nChanges.moveEndToEndOfNextInline = change => {\n  change.call(pointEdgeSideObject, 'end', 'end', 'next', 'inline')\n}\n\nChanges.moveEndToEndOfNextText = change => {\n  change.call(pointEdgeSideObject, 'end', 'end', 'next', 'text')\n}\n\nChanges.moveEndToEndOfNode = (change, ...args) => {\n  change.call(proxy, 'moveEndToEndOfNode', ...args)\n}\n\nChanges.moveEndToEndOfPreviousBlock = change => {\n  change.call(pointEdgeSideObject, 'end', 'end', 'previous', 'block')\n}\n\nChanges.moveEndToEndOfPreviousInline = change => {\n  change.call(pointEdgeSideObject, 'end', 'end', 'previous', 'inline')\n}\n\nChanges.moveEndToEndOfPreviousText = change => {\n  change.call(pointEdgeSideObject, 'end', 'end', 'previous', 'text')\n}\n\nChanges.moveEndToEndOfText = change => {\n  change.call(pointEdgeObject, 'end', 'end', 'text')\n}\n\nChanges.moveEndToStartOfBlock = change => {\n  change.call(pointEdgeObject, 'end', 'start', 'block')\n}\n\nChanges.moveEndToStartOfDocument = change => {\n  change.moveEndToStartOfNode(change.value.document).moveToEnd()\n}\n\nChanges.moveEndToStartOfInline = change => {\n  change.call(pointEdgeObject, 'end', 'start', 'inline')\n}\n\nChanges.moveEndToStartOfNextBlock = change => {\n  change.call(pointEdgeSideObject, 'end', 'start', 'next', 'block')\n}\n\nChanges.moveEndToStartOfNextInline = change => {\n  change.call(pointEdgeSideObject, 'end', 'start', 'next', 'inline')\n}\n\nChanges.moveEndToStartOfNextText = change => {\n  change.call(pointEdgeSideObject, 'end', 'start', 'next', 'text')\n}\n\nChanges.moveEndToStartOfNode = (change, ...args) => {\n  change.call(proxy, 'moveEndToStartOfNode', ...args)\n}\n\nChanges.moveEndToStartOfPreviousBlock = change => {\n  change.call(pointEdgeSideObject, 'end', 'start', 'previous', 'block')\n}\n\nChanges.moveEndToStartOfPreviousInline = change => {\n  change.call(pointEdgeSideObject, 'end', 'start', 'previous', 'inline')\n}\n\nChanges.moveEndToStartOfPreviousText = change => {\n  change.call(pointEdgeSideObject, 'end', 'start', 'previous', 'text')\n}\n\nChanges.moveEndToStartOfText = change => {\n  change.call(pointEdgeObject, 'end', 'start', 'text')\n}\n\nChanges.moveFocusBackward = (change, ...args) => {\n  change.call(pointBackward, 'focus', ...args)\n}\n\nChanges.moveFocusForward = (change, ...args) => {\n  change.call(pointForward, 'focus', ...args)\n}\n\nChanges.moveFocusTo = (change, ...args) => {\n  change.call(proxy, 'moveFocusTo', ...args)\n}\n\nChanges.moveFocusToEndOfBlock = change => {\n  change.call(pointEdgeObject, 'focus', 'end', 'block')\n}\n\nChanges.moveFocusToEndOfDocument = change => {\n  change.moveFocusToEndOfNode(change.value.document).moveToFocus()\n}\n\nChanges.moveFocusToEndOfInline = change => {\n  change.call(pointEdgeObject, 'focus', 'end', 'inline')\n}\n\nChanges.moveFocusToEndOfNextBlock = change => {\n  change.call(pointEdgeSideObject, 'focus', 'end', 'next', 'block')\n}\n\nChanges.moveFocusToEndOfNextInline = change => {\n  change.call(pointEdgeSideObject, 'focus', 'end', 'next', 'inline')\n}\n\nChanges.moveFocusToEndOfNextText = change => {\n  change.call(pointEdgeSideObject, 'focus', 'end', 'next', 'text')\n}\n\nChanges.moveFocusToEndOfNode = (change, ...args) => {\n  change.call(proxy, 'moveFocusToEndOfNode', ...args)\n}\n\nChanges.moveFocusToEndOfPreviousBlock = change => {\n  change.call(pointEdgeSideObject, 'focus', 'end', 'previous', 'block')\n}\n\nChanges.moveFocusToEndOfPreviousInline = change => {\n  change.call(pointEdgeSideObject, 'focus', 'end', 'previous', 'inline')\n}\n\nChanges.moveFocusToEndOfPreviousText = change => {\n  change.call(pointEdgeSideObject, 'focus', 'end', 'previous', 'text')\n}\n\nChanges.moveFocusToEndOfText = change => {\n  change.call(pointEdgeObject, 'focus', 'end', 'text')\n}\n\nChanges.moveFocusToStartOfBlock = change => {\n  change.call(pointEdgeObject, 'focus', 'start', 'block')\n}\n\nChanges.moveFocusToStartOfDocument = change => {\n  change.moveFocusToStartOfNode(change.value.document).moveToFocus()\n}\n\nChanges.moveFocusToStartOfInline = change => {\n  change.call(pointEdgeObject, 'focus', 'start', 'inline')\n}\n\nChanges.moveFocusToStartOfNextBlock = change => {\n  change.call(pointEdgeSideObject, 'focus', 'start', 'next', 'block')\n}\n\nChanges.moveFocusToStartOfNextInline = change => {\n  change.call(pointEdgeSideObject, 'focus', 'start', 'next', 'inline')\n}\n\nChanges.moveFocusToStartOfNextText = change => {\n  change.call(pointEdgeSideObject, 'focus', 'start', 'next', 'text')\n}\n\nChanges.moveFocusToStartOfNode = (change, ...args) => {\n  change.call(proxy, 'moveFocusToStartOfNode', ...args)\n}\n\nChanges.moveFocusToStartOfPreviousBlock = change => {\n  change.call(pointEdgeSideObject, 'focus', 'start', 'previous', 'block')\n}\n\nChanges.moveFocusToStartOfPreviousInline = change => {\n  change.call(pointEdgeSideObject, 'focus', 'start', 'previous', 'inline')\n}\n\nChanges.moveFocusToStartOfPreviousText = change => {\n  change.call(pointEdgeSideObject, 'focus', 'start', 'previous', 'text')\n}\n\nChanges.moveFocusToStartOfText = change => {\n  change.call(pointEdgeObject, 'focus', 'start', 'text')\n}\n\nChanges.moveForward = (change, ...args) => {\n  change.moveAnchorForward(...args).moveFocusForward(...args)\n}\n\nChanges.moveStartBackward = (change, ...args) => {\n  change.call(pointBackward, 'start', ...args)\n}\n\nChanges.moveStartForward = (change, ...args) => {\n  change.call(pointForward, 'start', ...args)\n}\n\nChanges.moveStartTo = (change, ...args) => {\n  change.call(proxy, 'moveStartTo', ...args)\n}\n\nChanges.moveStartToEndOfBlock = change => {\n  change.call(pointEdgeObject, 'start', 'end', 'block')\n}\n\nChanges.moveStartToEndOfDocument = change => {\n  change.moveStartToEndOfNode(change.value.document).moveToStart()\n}\n\nChanges.moveStartToEndOfInline = change => {\n  change.call(pointEdgeObject, 'start', 'end', 'inline')\n}\n\nChanges.moveStartToEndOfNextBlock = change => {\n  change.call(pointEdgeSideObject, 'start', 'end', 'next', 'block')\n}\n\nChanges.moveStartToEndOfNextInline = change => {\n  change.call(pointEdgeSideObject, 'start', 'end', 'next', 'inline')\n}\n\nChanges.moveStartToEndOfNextText = change => {\n  change.call(pointEdgeSideObject, 'start', 'end', 'next', 'text')\n}\n\nChanges.moveStartToEndOfNode = (change, ...args) => {\n  change.call(proxy, 'moveStartToEndOfNode', ...args)\n}\n\nChanges.moveStartToEndOfPreviousBlock = change => {\n  change.call(pointEdgeSideObject, 'start', 'end', 'previous', 'block')\n}\n\nChanges.moveStartToEndOfPreviousInline = change => {\n  change.call(pointEdgeSideObject, 'start', 'end', 'previous', 'inline')\n}\n\nChanges.moveStartToEndOfPreviousText = change => {\n  change.call(pointEdgeSideObject, 'start', 'end', 'previous', 'text')\n}\n\nChanges.moveStartToEndOfText = change => {\n  change.call(pointEdgeObject, 'start', 'end', 'text')\n}\n\nChanges.moveStartToStartOfBlock = change => {\n  change.call(pointEdgeObject, 'start', 'start', 'block')\n}\n\nChanges.moveStartToStartOfDocument = change => {\n  change.moveStartToStartOfNode(change.value.document).moveToStart()\n}\n\nChanges.moveStartToStartOfInline = change => {\n  change.call(pointEdgeObject, 'start', 'start', 'inline')\n}\n\nChanges.moveStartToStartOfNextBlock = change => {\n  change.call(pointEdgeSideObject, 'start', 'start', 'next', 'block')\n}\n\nChanges.moveStartToStartOfNextInline = change => {\n  change.call(pointEdgeSideObject, 'start', 'start', 'next', 'inline')\n}\n\nChanges.moveStartToStartOfNextText = change => {\n  change.call(pointEdgeSideObject, 'start', 'start', 'next', 'text')\n}\n\nChanges.moveStartToStartOfNode = (change, ...args) => {\n  change.call(proxy, 'moveStartToStartOfNode', ...args)\n}\n\nChanges.moveStartToStartOfPreviousBlock = change => {\n  change.call(pointEdgeSideObject, 'start', 'start', 'previous', 'block')\n}\n\nChanges.moveStartToStartOfPreviousInline = change => {\n  change.call(pointEdgeSideObject, 'start', 'start', 'previous', 'inline')\n}\n\nChanges.moveStartToStartOfPreviousText = change => {\n  change.call(pointEdgeSideObject, 'start', 'start', 'previous', 'text')\n}\n\nChanges.moveStartToStartOfText = change => {\n  change.call(pointEdgeObject, 'start', 'start', 'text')\n}\n\nChanges.moveTo = (change, ...args) => {\n  change.call(proxy, 'moveTo', ...args)\n}\n\nChanges.moveToAnchor = change => {\n  change.call(proxy, 'moveToAnchor')\n}\n\nChanges.moveToEnd = change => {\n  change.call(proxy, 'moveToEnd')\n}\n\nChanges.moveToEndOfBlock = change => {\n  change.moveEndToEndOfBlock().moveToEnd()\n}\n\nChanges.moveToEndOfDocument = change => {\n  change.moveEndToEndOfNode(change.value.document).moveToEnd()\n}\n\nChanges.moveToEndOfInline = change => {\n  change.moveEndToEndOfInline().moveToEnd()\n}\n\nChanges.moveToEndOfNextBlock = change => {\n  change.moveEndToEndOfNextBlock().moveToEnd()\n}\n\nChanges.moveToEndOfNextInline = change => {\n  change.moveEndToEndOfNextInline().moveToEnd()\n}\n\nChanges.moveToEndOfNextText = change => {\n  change.moveEndToEndOfNextText().moveToEnd()\n}\n\nChanges.moveToEndOfNode = (change, ...args) => {\n  change.call(proxy, 'moveToEndOfNode', ...args)\n}\n\nChanges.moveToEndOfPreviousBlock = change => {\n  change.moveStartToEndOfPreviousBlock().moveToStart()\n}\n\nChanges.moveToEndOfPreviousInline = change => {\n  change.moveStartToEndOfPreviousInline().moveToStart()\n}\n\nChanges.moveToEndOfPreviousText = change => {\n  change.moveStartToEndOfPreviousText().moveToStart()\n}\n\nChanges.moveToEndOfText = change => {\n  change.moveEndToEndOfText().moveToEnd()\n}\n\nChanges.moveToFocus = change => {\n  change.call(proxy, 'moveToFocus')\n}\n\nChanges.moveToRangeOfDocument = change => {\n  change.moveToRangeOfNode(change.value.document)\n}\n\nChanges.moveToRangeOfNode = (change, ...args) => {\n  change.call(proxy, 'moveToRangeOfNode', ...args)\n}\n\nChanges.moveToStart = change => {\n  change.call(proxy, 'moveToStart')\n}\n\nChanges.moveToStartOfBlock = change => {\n  change.moveStartToStartOfBlock().moveToStart()\n}\n\nChanges.moveToStartOfDocument = change => {\n  change.moveStartToStartOfNode(change.value.document).moveToStart()\n}\n\nChanges.moveToStartOfInline = change => {\n  change.moveStartToStartOfInline().moveToStart()\n}\n\nChanges.moveToStartOfNextBlock = change => {\n  change.moveEndToStartOfNextBlock().moveToEnd()\n}\n\nChanges.moveToStartOfNextInline = change => {\n  change.moveEndToStartOfNextInline().moveToEnd()\n}\n\nChanges.moveToStartOfNextText = change => {\n  change.moveEndToStartOfNextText().moveToEnd()\n}\n\nChanges.moveToStartOfNode = (change, ...args) => {\n  change.call(proxy, 'moveToStartOfNode', ...args)\n}\n\nChanges.moveToStartOfPreviousBlock = change => {\n  change.moveStartToStartOfPreviousBlock().moveToStart()\n}\n\nChanges.moveToStartOfPreviousInline = change => {\n  change.moveStartToStartOfPreviousInline().moveToStart()\n}\n\nChanges.moveToStartOfPreviousText = change => {\n  change.moveStartToStartOfPreviousText().moveToStart()\n}\n\nChanges.moveToStartOfText = change => {\n  change.moveStartToStartOfText().moveToStart()\n}\n\nChanges.select = (change, properties, options = {}) => {\n  properties = Selection.createProperties(properties)\n  const { snapshot = false } = options\n  const { value } = change\n  const { document, selection } = value\n  const props = {}\n  let next = selection.setProperties(properties)\n  next = document.resolveSelection(next)\n\n  // Re-compute the properties, to ensure that we get their normalized values.\n  properties = pick(next, Object.keys(properties))\n\n  // Remove any properties that are already equal to the current selection. And\n  // create a dictionary of the previous values for all of the properties that\n  // are being changed, for the inverse operation.\n  for (const k in properties) {\n    if (snapshot === true || !is(properties[k], selection[k])) {\n      props[k] = properties[k]\n    }\n  }\n\n  // If the selection moves, clear any marks, unless the new selection\n  // properties change the marks in some way.\n  if (selection.marks && !props.marks && (props.anchor || props.focus)) {\n    props.marks = null\n  }\n\n  // If there are no new properties to set, abort to avoid extra operations.\n  if (Object.keys(props).length === 0) {\n    return\n  }\n\n  change.applyOperation(\n    {\n      type: 'set_selection',\n      value,\n      properties: props,\n      selection: selection.toJSON(),\n    },\n    snapshot ? { skip: false, merge: false } : {}\n  )\n}\n\nChanges.setAnchor = (change, ...args) => {\n  change.call(proxy, 'setAnchor', ...args)\n}\n\nChanges.setEnd = (change, ...args) => {\n  change.call(proxy, 'setEnd', ...args)\n}\n\nChanges.setFocus = (change, ...args) => {\n  change.call(proxy, 'setFocus', ...args)\n}\n\nChanges.setStart = (change, ...args) => {\n  change.call(proxy, 'setStart', ...args)\n}\n\nChanges.snapshotSelection = change => {\n  change.select(change.value.selection, { snapshot: true })\n}\n\n/**\n * Helpers.\n */\n\nfunction proxy(change, method, ...args) {\n  const range = change.value.selection[method](...args)\n  change.select(range)\n}\n\nfunction pointEdgeObject(change, point, edge, object) {\n  const Point = point.slice(0, 1).toUpperCase() + point.slice(1)\n  const Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1)\n  const Object = object.slice(0, 1).toUpperCase() + object.slice(1)\n  const method = `move${Point}To${Edge}OfNode`\n  const getNode = object == 'text' ? 'getNode' : `getClosest${Object}`\n  const { value } = change\n  const { document, selection } = value\n  const p = selection[point]\n  const node = document[getNode](p.key)\n  if (!node) return\n  change[method](node)\n}\n\nfunction pointEdgeSideObject(change, point, edge, side, object) {\n  const Point = point.slice(0, 1).toUpperCase() + point.slice(1)\n  const Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1)\n  const Side = side.slice(0, 1).toUpperCase() + side.slice(1)\n  const Object = object.slice(0, 1).toUpperCase() + object.slice(1)\n  const method = `move${Point}To${Edge}OfNode`\n  const getNode = object == 'text' ? 'getNode' : `getClosest${Object}`\n  const getDirectionNode = `get${Side}${Object}`\n  const { value } = change\n  const { document, selection } = value\n  const p = selection[point]\n  const node = document[getNode](p.key)\n  if (!node) return\n  const target = document[getDirectionNode](node.key)\n  if (!target) return\n  change[method](target)\n}\n\nfunction pointBackward(change, point, n = 1) {\n  if (n === 0) return\n  if (n < 0) return pointForward(change, point, -n)\n\n  const Point = point.slice(0, 1).toUpperCase() + point.slice(1)\n  const { value } = change\n  const { document, selection, schema } = value\n  const p = selection[point]\n  const hasVoidParent = document.hasVoidParent(p.path, schema)\n\n  // what is this?\n  if (!hasVoidParent && p.offset - n >= 0) {\n    const range = selection[`move${Point}Backward`](n)\n    change.select(range)\n    return\n  }\n\n  const previous = document.getPreviousText(p.path)\n  if (!previous) return\n\n  const block = document.getClosestBlock(p.path)\n  const isInBlock = block.hasNode(previous.key)\n  const isPreviousInVoid =\n    previous && document.hasVoidParent(previous.key, schema)\n  change[`move${Point}ToEndOfNode`](previous)\n\n  // when is this called?\n  if (!hasVoidParent && !isPreviousInVoid && isInBlock) {\n    const range = change.value.selection[`move${Point}Backward`](n)\n    change.select(range)\n  }\n}\n\nfunction pointForward(change, point, n = 1) {\n  if (n === 0) return\n  if (n < 0) return pointBackward(change, point, -n)\n\n  const Point = point.slice(0, 1).toUpperCase() + point.slice(1)\n  const { value } = change\n  const { document, selection, schema } = value\n  const p = selection[point]\n  const text = document.getNode(p.path)\n  const hasVoidParent = document.hasVoidParent(p.path, schema)\n\n  // what is this?\n  if (!hasVoidParent && p.offset + n <= text.text.length) {\n    const range = selection[`move${Point}Forward`](n)\n    change.select(range)\n    return\n  }\n\n  const next = document.getNextText(p.path)\n  if (!next) return\n\n  const block = document.getClosestBlock(p.path)\n  const isInBlock = block.hasNode(next.key)\n  const isNextInVoid = document.hasVoidParent(next.key, schema)\n  change[`move${Point}ToStartOfNode`](next)\n\n  // when is this called?\n  if (!hasVoidParent && !isNextInVoid && isInBlock) {\n    const range = change.value.selection[`move${Point}Forward`](n)\n    change.select(range)\n  }\n}\n\nexport default Changes\n","import Value from '../models/value'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Set `properties` on the value.\n *\n * @param {Change} change\n * @param {Object|Value} properties\n * @param {Object} options\n */\n\nChanges.setValue = (change, properties, options = {}) => {\n  properties = Value.createProperties(properties)\n  const { value } = change\n\n  change.applyOperation(\n    {\n      type: 'set_value',\n      properties,\n      value,\n    },\n    options\n  )\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import PathUtils from '../utils/path-utils'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Normalize the value with its schema.\n *\n * @param {Change} change\n */\n\nChanges.normalize = (change, options) => {\n  change.normalizeDocument(options)\n}\n\n/**\n * Normalize the document with the value's schema.\n *\n * @param {Change} change\n */\n\nChanges.normalizeDocument = (change, options) => {\n  const { value } = change\n  const { document } = value\n  change.normalizeNodeByKey(document.key, options)\n}\n\n/**\n * Normalize a `node` and its children with the value's schema.\n *\n * @param {Change} change\n * @param {Node|String} key\n */\n\nChanges.normalizeNodeByKey = (change, key, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  if (!normalize) return\n\n  const { value } = change\n  const { document, schema } = value\n  const node = document.assertNode(key)\n\n  normalizeNodeAndChildren(change, node, schema)\n\n  change.normalizeAncestorsByKey(key)\n}\n\n/**\n * Normalize a node's ancestors by `key`.\n *\n * @param {Change} change\n * @param {String} key\n */\n\nChanges.normalizeAncestorsByKey = (change, key) => {\n  const { value } = change\n  const { document, schema } = value\n  const ancestors = document.getAncestors(key)\n  if (!ancestors) return\n\n  ancestors.forEach(ancestor => {\n    if (change.value.document.getDescendant(ancestor.key)) {\n      normalizeNode(change, ancestor, schema)\n    }\n  })\n}\n\nChanges.normalizeParentByKey = (change, key, options) => {\n  const { value } = change\n  const { document } = value\n  const parent = document.getParent(key)\n  change.normalizeNodeByKey(parent.key, options)\n}\n\n/**\n * Normalize a `node` and its children with the value's schema.\n *\n * @param {Change} change\n * @param {Array} path\n */\n\nChanges.normalizeNodeByPath = (change, path, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  if (!normalize) return\n\n  const { value } = change\n  let { document, schema } = value\n  const node = document.assertNode(path)\n\n  normalizeNodeAndChildren(change, node, schema)\n\n  document = change.value.document\n  const ancestors = document.getAncestors(path)\n  if (!ancestors) return\n\n  ancestors.forEach(ancestor => {\n    if (change.value.document.getDescendant(ancestor.key)) {\n      normalizeNode(change, ancestor, schema)\n    }\n  })\n}\n\nChanges.normalizeParentByPath = (change, path, options) => {\n  const p = PathUtils.lift(path)\n  change.normalizeNodeByPath(p, options)\n}\n\n/**\n * Normalize a `node` and its children with a `schema`.\n *\n * @param {Change} change\n * @param {Node} node\n * @param {Schema} schema\n */\n\nfunction normalizeNodeAndChildren(change, node, schema) {\n  if (node.object == 'text') {\n    normalizeNode(change, node, schema)\n    return\n  }\n\n  let child = node.getFirstInvalidNode(schema)\n  let path = change.value.document.getPath(node.key)\n\n  while (node && child) {\n    normalizeNodeAndChildren(change, child, schema)\n    node = change.value.document.refindNode(path, node.key)\n\n    if (!node) {\n      path = []\n      child = null\n    } else {\n      path = change.value.document.refindPath(path, node.key)\n      child = node.getFirstInvalidNode(schema)\n    }\n  }\n\n  // Normalize the node itself if it still exists.\n  if (node) {\n    normalizeNode(change, node, schema)\n  }\n}\n\n/**\n * Normalize a `node` with a `schema`, but not its children.\n *\n * @param {Change} change\n * @param {Node} node\n * @param {Schema} schema\n */\n\nfunction normalizeNode(change, node, schema) {\n  const max =\n    schema.stack.plugins.length +\n    schema.rules.length +\n    (node.object === 'text' ? 1 : node.nodes.size)\n\n  let iterations = 0\n\n  function iterate(c, n) {\n    const normalize = n.normalize(schema)\n    if (!normalize) return\n\n    // Run the `normalize` function to fix the node.\n    let path = c.value.document.getPath(n.key)\n    normalize(c)\n\n    // Re-find the node reference, in case it was updated. If the node no longer\n    // exists, we're done for this branch.\n    n = c.value.document.refindNode(path, n.key)\n    if (!n) return\n\n    path = c.value.document.refindPath(path, n.key)\n\n    // Increment the iterations counter, and check to make sure that we haven't\n    // exceeded the max. Without this check, it's easy for the `normalize`\n    // function of a schema rule to be written incorrectly and for an infinite\n    // invalid loop to occur.\n    iterations++\n\n    if (iterations > max) {\n      throw new Error(\n        'A schema rule could not be normalized after sufficient iterations. This is usually due to a `rule.normalize` or `plugin.normalizeNode` function of a schema being incorrectly written, causing an infinite loop.'\n      )\n    }\n\n    // Otherwise, iterate again.\n    iterate(c, n)\n  }\n\n  iterate(change, node)\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import AtCurrentRange from './at-current-range'\nimport AtRange from './at-range'\nimport ByPath from './by-path'\nimport OnHistory from './on-history'\nimport OnSelection from './on-selection'\nimport OnValue from './on-value'\nimport WithSchema from './with-schema'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  ...AtCurrentRange,\n  ...AtRange,\n  ...ByPath,\n  ...OnHistory,\n  ...OnSelection,\n  ...OnValue,\n  ...WithSchema,\n}\n","import Debug from 'debug'\n\nimport Operation from '../models/operation'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:operation:apply')\n\n/**\n * Apply an `op` to a `value`.\n *\n * @param {Value} value\n * @param {Object|Operation} op\n * @return {Value} value\n */\n\nfunction applyOperation(value, op) {\n  op = Operation.create(op)\n  const { type } = op\n  debug(type, op)\n\n  switch (type) {\n    case 'add_mark': {\n      const { path, offset, length, mark } = op\n      const next = value.addMark(path, offset, length, mark)\n      return next\n    }\n\n    case 'insert_node': {\n      const { path, node } = op\n      const next = value.insertNode(path, node)\n      return next\n    }\n\n    case 'insert_text': {\n      const { path, offset, text, marks } = op\n      const next = value.insertText(path, offset, text, marks)\n      return next\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const next = value.mergeNode(path)\n      return next\n    }\n\n    case 'move_node': {\n      const { path, newPath } = op\n      const next = value.moveNode(path, newPath)\n      return next\n    }\n\n    case 'remove_mark': {\n      const { path, offset, length, mark } = op\n      const next = value.removeMark(path, offset, length, mark)\n      return next\n    }\n\n    case 'remove_node': {\n      const { path } = op\n      const next = value.removeNode(path)\n      return next\n    }\n\n    case 'remove_text': {\n      const { path, offset, text } = op\n      const next = value.removeText(path, offset, text)\n      return next\n    }\n\n    case 'set_mark': {\n      const { path, offset, length, mark, properties } = op\n      const next = value.setMark(path, offset, length, mark, properties)\n      return next\n    }\n\n    case 'set_node': {\n      const { path, properties } = op\n      const next = value.setNode(path, properties)\n      return next\n    }\n\n    case 'set_selection': {\n      const { properties } = op\n      const next = value.setSelection(properties)\n      return next\n    }\n\n    case 'set_value': {\n      const { properties } = op\n      const next = value.setProperties(properties)\n      return next\n    }\n\n    case 'split_node': {\n      const { path, position, properties } = op\n      const next = value.splitNode(path, position, properties)\n      return next\n    }\n\n    default: {\n      throw new Error(`Unknown operation type: \"${type}\".`)\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default applyOperation\n","import Debug from 'debug'\nimport isPlainObject from 'is-plain-object'\nimport pick from 'lodash/pick'\nimport { List } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport Changes from '../changes'\nimport Operation from './operation'\nimport apply from '../operations/apply'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:change')\n\n/**\n * Change.\n *\n * @type {Change}\n */\n\nclass Change {\n  /**\n   * Check if `any` is a `Change`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isChange = isType.bind(null, 'CHANGE')\n\n  /**\n   * Create a new `Change` with `attrs`.\n   *\n   * @param {Object} attrs\n   *   @property {Value} value\n   */\n\n  constructor(attrs) {\n    const { value } = attrs\n    this.value = value\n    this.operations = new List()\n\n    this.flags = {\n      normalize: true,\n      ...pick(attrs, ['merge', 'save', 'normalize']),\n    }\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'change'\n  }\n\n  /**\n   * Apply an `operation` to the current value, saving the operation to the\n   * history if needed.\n   *\n   * @param {Operation|Object} operation\n   * @param {Object} options\n   * @return {Change}\n   */\n\n  applyOperation(operation, options = {}) {\n    const { operations, flags } = this\n    let { value } = this\n    let { history } = value\n\n    // Add in the current `value` in case the operation was serialized.\n    if (isPlainObject(operation)) {\n      operation = { ...operation, value }\n    }\n\n    operation = Operation.create(operation)\n\n    // Default options to the change-level flags, this allows for setting\n    // specific options for all of the operations of a given change.\n    options = { ...flags, ...options }\n\n    // Derive the default option values.\n    const {\n      merge = operations.size == 0 ? null : true,\n      save = true,\n      skip = null,\n    } = options\n\n    // Apply the operation to the value.\n    debug('apply', { operation, save, merge })\n    value = apply(value, operation)\n\n    // If needed, save the operation to the history.\n    if (history && save) {\n      history = history.save(operation, { merge, skip })\n      value = value.set('history', history)\n    }\n\n    // Update the mutable change object.\n    this.value = value\n    this.operations = operations.push(operation)\n    return this\n  }\n\n  /**\n   * Apply a series of `operations` to the current value.\n   *\n   * @param {Array|List} operations\n   * @param {Object} options\n   * @return {Change}\n   */\n\n  applyOperations(operations, options) {\n    operations.forEach(op => this.applyOperation(op, options))\n    return this\n  }\n\n  /**\n   * Call a change `fn` with arguments.\n   *\n   * @param {Function} fn\n   * @param {Mixed} ...args\n   * @return {Change}\n   */\n\n  call(fn, ...args) {\n    fn(this, ...args)\n    return this\n  }\n\n  /**\n   * Applies a series of change mutations, deferring normalization to the end.\n   *\n   * @param {Function} fn\n   * @return {Change}\n   */\n\n  withoutNormalization(fn) {\n    const original = this.flags.normalize\n    this.setOperationFlag('normalize', false)\n    fn(this)\n    this.setOperationFlag('normalize', original)\n    this.normalizeDocument()\n    return this\n  }\n\n  /**\n   * Set an operation flag by `key` to `value`.\n   *\n   * @param {String} key\n   * @param {Any} value\n   * @return {Change}\n   */\n\n  setOperationFlag(key, value) {\n    this.flags[key] = value\n    return this\n  }\n\n  /**\n   * Get the `value` of the specified flag by its `key`. Optionally accepts an `options`\n   * object with override flags.\n   *\n   * @param {String} key\n   * @param {Object} options\n   * @return {Change}\n   */\n\n  getFlag(key, options = {}) {\n    return options[key] !== undefined ? options[key] : this.flags[key]\n  }\n\n  /**\n   * Unset an operation flag by `key`.\n   *\n   * @param {String} key\n   * @return {Change}\n   */\n\n  unsetOperationFlag(key) {\n    delete this.flags[key]\n    return this\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nChange.prototype[MODEL_TYPES.CHANGE] = true\n\n/**\n * Add a change method for each of the changes.\n */\n\nObject.keys(Changes).forEach(type => {\n  Change.prototype[type] = function(...args) {\n    debug(type, { args })\n    this.call(Changes[type], ...args)\n    return this\n  }\n})\n\n/**\n * Export.\n *\n * @type {Change}\n */\n\nexport default Change\n","import mixin from '../utils/mixin'\nimport Block from '../models/block'\nimport Change from '../models/change'\nimport Decoration from '../models/decoration'\nimport Document from '../models/document'\nimport History from '../models/history'\nimport Inline from '../models/inline'\nimport Leaf from '../models/leaf'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport Operation from '../models/operation'\nimport Point from '../models/point'\nimport Range from '../models/range'\nimport Schema from '../models/schema'\nimport Selection from '../models/selection'\nimport Stack from '../models/stack'\nimport Text from '../models/text'\nimport Value from '../models/value'\n\n/**\n * The interface that all Slate models implement.\n *\n * @type {Class}\n */\n\nclass CommonInterface {\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS(...args) {\n    return this.fromJSON(...args)\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(...args) {\n    return this.toJSON(...args)\n  }\n}\n\n/**\n * Mix in the common interface.\n *\n * @param {Record}\n */\n\nmixin(CommonInterface, [\n  Block,\n  Change,\n  Decoration,\n  Document,\n  History,\n  Inline,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  Point,\n  Range,\n  Schema,\n  Selection,\n  Stack,\n  Text,\n  Value,\n])\n","import direction from 'direction'\nimport { List, OrderedSet, Set } from 'immutable'\n\nimport mixin from '../utils/mixin'\nimport Block from '../models/block'\nimport Decoration from '../models/decoration'\nimport Document from '../models/document'\nimport Inline from '../models/inline'\nimport memoize from '../utils/memoize'\nimport PathUtils from '../utils/path-utils'\nimport Point from '../models/point'\nimport Range from '../models/range'\nimport Selection from '../models/selection'\n\n/**\n * The interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Class}\n */\n\nclass ElementInterface {\n  /**\n   * Add mark to text at `offset` and `length` in node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Node}\n   */\n\n  addMark(path, offset, length, mark) {\n    let node = this.assertDescendant(path)\n    path = this.resolvePath(path)\n    node = node.addMark(offset, length, mark)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Create a decoration with `properties` relative to the node.\n   *\n   * @param {Object|Decoration} properties\n   * @return {Decoration}\n   */\n\n  createDecoration(properties) {\n    properties = Decoration.createProperties(properties)\n    const decoration = this.resolveDecoration(properties)\n    return decoration\n  }\n\n  /**\n   * Create a point with `properties` relative to the node.\n   *\n   * @param {Object|Point} properties\n   * @return {Range}\n   */\n\n  createPoint(properties) {\n    properties = Point.createProperties(properties)\n    const point = this.resolvePoint(properties)\n    return point\n  }\n\n  /**\n   * Create a range with `properties` relative to the node.\n   *\n   * @param {Object|Range} properties\n   * @return {Range}\n   */\n\n  createRange(properties) {\n    properties = Range.createProperties(properties)\n    const range = this.resolveRange(properties)\n    return range\n  }\n\n  /**\n   * Create a selection with `properties` relative to the node.\n   *\n   * @param {Object|Selection} properties\n   * @return {Selection}\n   */\n\n  createSelection(properties) {\n    properties = Selection.createProperties(properties)\n    const selection = this.resolveSelection(properties)\n    return selection\n  }\n\n  /**\n   * Recursively filter all descendant nodes with `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {List<Node>}\n   */\n\n  filterDescendants(iterator) {\n    const matches = []\n\n    this.forEachDescendant((node, i, nodes) => {\n      if (iterator(node, i, nodes)) matches.push(node)\n    })\n\n    return List(matches)\n  }\n\n  /**\n   * Recursively find all descendant nodes by `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  findDescendant(iterator) {\n    let found = null\n\n    this.forEachDescendant((node, i, nodes) => {\n      if (iterator(node, i, nodes)) {\n        found = node\n        return false\n      }\n    })\n\n    return found\n  }\n\n  /**\n   * Recursively iterate over all descendant nodes with `iterator`. If the\n   * iterator returns false it will break the loop.\n   *\n   * @param {Function} iterator\n   */\n\n  forEachDescendant(iterator) {\n    let ret\n\n    this.nodes.forEach((child, i, nodes) => {\n      if (iterator(child, i, nodes) === false) {\n        ret = false\n        return false\n      }\n\n      if (child.object != 'text') {\n        ret = child.forEachDescendant(iterator)\n        return ret\n      }\n    })\n\n    return ret\n  }\n\n  /**\n   * Get a set of the active marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getActiveMarksAtRange(range) {\n    range = this.resolveRange(range)\n    if (range.isUnset) return Set()\n\n    if (range.isCollapsed) {\n      const { start } = range\n      return this.getMarksAtPosition(start.key, start.offset).toSet()\n    }\n\n    const { start, end } = range\n    let startKey = start.key\n    let startOffset = start.offset\n    let endKey = end.key\n    let endOffset = end.offset\n    let startText = this.getDescendant(startKey)\n\n    if (startKey !== endKey) {\n      while (startKey !== endKey && endOffset === 0) {\n        const endText = this.getPreviousText(endKey)\n        endKey = endText.key\n        endOffset = endText.text.length\n      }\n\n      while (startKey !== endKey && startOffset === startText.text.length) {\n        startText = this.getNextText(startKey)\n        startKey = startText.key\n        startOffset = 0\n      }\n    }\n\n    if (startKey === endKey) {\n      return startText.getActiveMarksBetweenOffsets(startOffset, endOffset)\n    }\n\n    const startMarks = startText.getActiveMarksBetweenOffsets(\n      startOffset,\n      startText.text.length\n    )\n    if (startMarks.size === 0) return Set()\n    const endText = this.getDescendant(endKey)\n    const endMarks = endText.getActiveMarksBetweenOffsets(0, endOffset)\n    let marks = startMarks.intersect(endMarks)\n    // If marks is already empty, the active marks is empty\n    if (marks.size === 0) return marks\n\n    let text = this.getNextText(startKey)\n\n    while (text.key !== endKey) {\n      if (text.text.length !== 0) {\n        marks = marks.intersect(text.getActiveMarks())\n        if (marks.size === 0) return Set()\n      }\n\n      text = this.getNextText(text.key)\n    }\n    return marks\n  }\n\n  /**\n   * Get a list of the ancestors of a descendant.\n   *\n   * @param {List|String} path\n   * @return {List<Node>|Null}\n   */\n\n  getAncestors(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n\n    const ancestors = []\n\n    path.forEach((p, i) => {\n      const current = path.slice(0, i)\n      const parent = this.getNode(current)\n      ancestors.push(parent)\n    })\n\n    return List(ancestors)\n  }\n\n  /**\n   * Get the leaf block descendants of the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getBlocks() {\n    const array = this.getBlocksAsArray()\n    return List(array)\n  }\n\n  /**\n   * Get the leaf block descendants of the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getBlocksAsArray() {\n    return this.nodes.reduce((array, child) => {\n      if (child.object != 'block') return array\n      if (!child.isLeafBlock()) return array.concat(child.getBlocksAsArray())\n      array.push(child)\n      return array\n    }, [])\n  }\n\n  /**\n   * Get the leaf block descendants in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getBlocksAtRange(range) {\n    const array = this.getBlocksAtRangeAsArray(range)\n    // Eliminate duplicates by converting to an `OrderedSet` first.\n    return List(OrderedSet(array))\n  }\n\n  /**\n   * Get the leaf block descendants in a `range` as an array\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getBlocksAtRangeAsArray(range) {\n    range = this.resolveRange(range)\n    if (range.isUnset) return []\n\n    const { start, end } = range\n    const startBlock = this.getClosestBlock(start.key)\n\n    // PERF: the most common case is when the range is in a single block node,\n    // where we can avoid a lot of iterating of the tree.\n    if (start.key === end.key) return [startBlock]\n\n    const endBlock = this.getClosestBlock(end.key)\n    const blocks = this.getBlocksAsArray()\n    const startIndex = blocks.indexOf(startBlock)\n    const endIndex = blocks.indexOf(endBlock)\n    return blocks.slice(startIndex, endIndex + 1)\n  }\n\n  /**\n   * Get all of the leaf blocks that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getBlocksByType(type) {\n    const array = this.getBlocksByTypeAsArray(type)\n    return List(array)\n  }\n\n  /**\n   * Get all of the leaf blocks that match a `type` as an array\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getBlocksByTypeAsArray(type) {\n    return this.nodes.reduce((array, node) => {\n      if (node.object != 'block') {\n        return array\n      } else if (node.isLeafBlock() && node.type == type) {\n        array.push(node)\n        return array\n      } else {\n        return array.concat(node.getBlocksByTypeAsArray(type))\n      }\n    }, [])\n  }\n\n  /**\n   * Get a child node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getChild(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    const child = path.size === 1 ? this.nodes.get(path.first()) : null\n    return child\n  }\n\n  /**\n   * Get closest parent of node that matches an `iterator`.\n   *\n   * @param {List|String} path\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  getClosest(path, iterator) {\n    const ancestors = this.getAncestors(path)\n    if (!ancestors) return null\n\n    const closest = ancestors.findLast((node, ...args) => {\n      // We never want to include the top-level node.\n      if (node === this) return false\n      return iterator(node, ...args)\n    })\n\n    return closest || null\n  }\n\n  /**\n   * Get the closest block parent of a node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getClosestBlock(path) {\n    const closest = this.getClosest(path, n => n.object === 'block')\n    return closest\n  }\n\n  /**\n   * Get the closest inline parent of a node by `path`.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getClosestInline(path) {\n    const closest = this.getClosest(path, n => n.object === 'inline')\n    return closest\n  }\n\n  /**\n   * Get the closest void parent of a node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Schema} schema\n   * @return {Node|Null}\n   */\n\n  getClosestVoid(path, schema) {\n    const ancestors = this.getAncestors(path)\n    const ancestor = ancestors.findLast(a => schema.isVoid(a))\n    return ancestor\n  }\n\n  /**\n   * Get the common ancestor of nodes `a` and `b`.\n   *\n   * @param {List} a\n   * @param {List} b\n   * @return {Node}\n   */\n\n  getCommonAncestor(a, b) {\n    a = this.resolvePath(a)\n    b = this.resolvePath(b)\n    if (!a || !b) return null\n\n    const path = PathUtils.relate(a, b)\n    const node = this.getNode(path)\n    return node\n  }\n\n  /**\n   * Get the decorations for the node from a `stack`.\n   *\n   * @param {Stack} stack\n   * @return {List}\n   */\n\n  getDecorations(stack) {\n    const decorations = stack.find('decorateNode', this)\n    const list = Decoration.createList(decorations || [])\n    return list\n  }\n\n  /**\n   * Get the depth of a descendant, with optional `startAt`.\n   *\n   * @param {List|String} path\n   * @param {Number} startAt\n   * @return {Number|Null}\n   */\n\n  getDepth(path, startAt = 1) {\n    path = this.resolvePath(path)\n    if (!path) return null\n\n    const node = this.getNode(path)\n    const depth = node ? path.size - 1 + startAt : null\n    return depth\n  }\n\n  /**\n   * Get a descendant node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getDescendant(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n\n    const deep = path.flatMap(x => ['nodes', x])\n    const ret = this.getIn(deep)\n    return ret\n  }\n\n  /**\n   * Get a fragment of the node at a `range`.\n   *\n   * @param {Range} range\n   * @return {Document}\n   */\n\n  getFragmentAtRange(range) {\n    range = this.resolveRange(range)\n\n    if (range.isUnset) {\n      return Document.create()\n    }\n\n    const { start, end } = range\n    let node = this\n    let targetPath = end.path\n    let targetPosition = end.offset\n    let mode = 'end'\n\n    while (targetPath.size) {\n      const index = targetPath.last()\n      node = node.splitNode(targetPath, targetPosition)\n      targetPosition = index + 1\n      targetPath = PathUtils.lift(targetPath)\n\n      if (!targetPath.size && mode === 'end') {\n        targetPath = start.path\n        targetPosition = start.offset\n        mode = 'start'\n      }\n    }\n\n    const startIndex = start.path.first() + 1\n    const endIndex = end.path.first() + 2\n    const nodes = node.nodes.slice(startIndex, endIndex)\n    const fragment = Document.create({ nodes })\n    return fragment\n  }\n\n  /**\n   * Get the furthest parent of a node that matches an `iterator`.\n   *\n   * @param {Path} path\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  getFurthest(path, iterator) {\n    const ancestors = this.getAncestors(path)\n    if (!ancestors) return null\n\n    const furthest = ancestors.find((node, ...args) => {\n      // We never want to include the top-level node.\n      if (node === this) return false\n      return iterator(node, ...args)\n    })\n\n    return furthest || null\n  }\n\n  /**\n   * Get the furthest ancestor of a node.\n   *\n   * @param {Path} path\n   * @return {Node|Null}\n   */\n\n  getFurthestAncestor(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    const furthest = path.size ? this.nodes.get(path.first()) : null\n    return furthest\n  }\n\n  /**\n   * Get the furthest block parent of a node.\n   *\n   * @param {Path} path\n   * @return {Node|Null}\n   */\n\n  getFurthestBlock(path) {\n    const furthest = this.getFurthest(path, n => n.object === 'block')\n    return furthest\n  }\n\n  /**\n   * Get the furthest inline parent of a node.\n   *\n   * @param {Path} path\n   * @return {Node|Null}\n   */\n\n  getFurthestInline(path) {\n    const furthest = this.getFurthest(path, n => n.object === 'inline')\n    return furthest\n  }\n\n  /**\n   * Get the furthest ancestor of a node that has only one child.\n   *\n   * @param {Path} path\n   * @return {Node|Null}\n   */\n\n  getFurthestOnlyChildAncestor(path) {\n    const ancestors = this.getAncestors(path)\n    if (!ancestors) return null\n\n    const furthest = ancestors\n      .rest()\n      .reverse()\n      .takeUntil(p => p.nodes.size > 1)\n      .last()\n\n    return furthest || null\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getInlines() {\n    const array = this.getInlinesAsArray()\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in the node, as an array.\n   *\n   * @return {List<Node>}\n   */\n\n  getInlinesAsArray() {\n    let array = []\n\n    this.nodes.forEach(child => {\n      if (child.object == 'text') return\n\n      if (child.isLeafInline()) {\n        array.push(child)\n      } else {\n        array = array.concat(child.getInlinesAsArray())\n      }\n    })\n\n    return array\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getInlinesAtRange(range) {\n    const array = this.getInlinesAtRangeAsArray(range)\n    // Remove duplicates by converting it to an `OrderedSet` first.\n    const list = List(OrderedSet(array))\n    return list\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in a `range` as an array.\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getInlinesAtRangeAsArray(range) {\n    range = this.resolveRange(range)\n    if (range.isUnset) return []\n\n    const array = this.getTextsAtRangeAsArray(range)\n      .map(text => this.getClosestInline(text.key))\n      .filter(exists => exists)\n\n    return array\n  }\n\n  /**\n   * Get all of the leaf inline nodes that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getInlinesByType(type) {\n    const array = this.getInlinesByTypeAsArray(type)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get all of the leaf inline nodes that match a `type` as an array.\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getInlinesByTypeAsArray(type) {\n    const array = this.nodes.reduce((inlines, node) => {\n      if (node.object == 'text') {\n        return inlines\n      } else if (node.isLeafInline() && node.type == type) {\n        inlines.push(node)\n        return inlines\n      } else {\n        return inlines.concat(node.getInlinesByTypeAsArray(type))\n      }\n    }, [])\n\n    return array\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getInsertMarksAtRange(range) {\n    range = this.resolveRange(range)\n    const { start } = range\n\n    if (range.isUnset) {\n      return Set()\n    }\n\n    if (range.isCollapsed) {\n      // PERF: range is not cachable, use key and offset as proxies for cache\n      return this.getMarksAtPosition(start.key, start.offset)\n    }\n\n    const text = this.getDescendant(start.key)\n    const marks = text.getMarksAtIndex(start.offset + 1)\n    return marks\n  }\n\n  /**\n   * Get all of the marks for all of the characters of every text node.\n   *\n   * @return {Set<Mark>}\n   */\n\n  getMarks() {\n    const array = this.getMarksAsArray()\n    return Set(array)\n  }\n\n  /**\n   * Get all of the marks as an array.\n   *\n   * @return {Array}\n   */\n\n  getMarksAsArray() {\n    const result = []\n\n    this.nodes.forEach(node => {\n      result.push(node.getMarksAsArray())\n    })\n\n    // PERF: use only one concat rather than multiple for speed.\n    const array = [].concat(...result)\n    return array\n  }\n\n  /**\n   * Get a set of marks in a `position`, the equivalent of a collapsed range\n   *\n   * @param {string} key\n   * @param {number} offset\n   * @return {Set}\n   */\n\n  getMarksAtPosition(key, offset) {\n    const text = this.getDescendant(key)\n    const currentMarks = text.getMarksAtIndex(offset)\n    if (offset !== 0) return currentMarks\n    const closestBlock = this.getClosestBlock(key)\n\n    if (closestBlock.text === '') {\n      // insert mark for empty block; the empty block are often created by split node or add marks in a range including empty blocks\n      return currentMarks\n    }\n\n    const previous = this.getPreviousText(key)\n    if (!previous) return Set()\n\n    if (closestBlock.hasDescendant(previous.key)) {\n      return previous.getMarksAtIndex(previous.text.length)\n    }\n\n    return currentMarks\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getMarksAtRange(range) {\n    const marks = Set(this.getOrderedMarksAtRange(range))\n    return marks\n  }\n\n  /**\n   * Get all of the marks that match a `type`.\n   *\n   * @param {String} type\n   * @return {Set<Mark>}\n   */\n\n  getMarksByType(type) {\n    const array = this.getMarksByTypeAsArray(type)\n    return Set(array)\n  }\n\n  /**\n   * Get all of the marks that match a `type` as an array.\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getMarksByTypeAsArray(type) {\n    const array = this.nodes.reduce((memo, node) => {\n      return node.object == 'text'\n        ? memo.concat(node.getMarksAsArray().filter(m => m.type == type))\n        : memo.concat(node.getMarksByTypeAsArray(type))\n    }, [])\n\n    return array\n  }\n\n  /**\n   * Get the block node before a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNextBlock(key) {\n    const child = this.assertDescendant(key)\n    let last\n\n    if (child.object == 'block') {\n      last = child.getLastText()\n    } else {\n      const block = this.getClosestBlock(key)\n      last = block.getLastText()\n    }\n\n    const next = this.getNextText(last.key)\n    if (!next) return null\n\n    const closest = this.getClosestBlock(next.key)\n    return closest\n  }\n\n  /**\n   * Get the next node in the tree from a node.\n   *\n   * This will not only check for siblings but instead move up the tree\n   * returning the next ancestor if no sibling is found.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNextNode(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n\n    for (let i = path.size; i > 0; i--) {\n      const p = path.slice(0, i)\n      const target = PathUtils.increment(p)\n      const node = this.getNode(target)\n      if (node) return node\n    }\n\n    return null\n  }\n\n  /**\n   * Get the next sibling of a node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNextSibling(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    const p = PathUtils.increment(path)\n    const sibling = this.getNode(p)\n    return sibling\n  }\n\n  /**\n   * Get the text node after a descendant text node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNextText(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    const next = this.getNextNode(path)\n    if (!next) return null\n    const text = next.getFirstText()\n    return text\n  }\n\n  /**\n   * Get the offset for a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Number}\n   */\n\n  getOffset(key) {\n    this.assertDescendant(key)\n\n    // Calculate the offset of the nodes before the highest child.\n    const child = this.getFurthestAncestor(key)\n    const offset = this.nodes\n      .takeUntil(n => n == child)\n      .reduce((memo, n) => memo + n.text.length, 0)\n\n    // Recurse if need be.\n    const ret = this.hasChild(key) ? offset : offset + child.getOffset(key)\n    return ret\n  }\n\n  /**\n   * Get the offset from a `range`.\n   *\n   * @param {Range} range\n   * @return {Number}\n   */\n\n  getOffsetAtRange(range) {\n    range = this.resolveRange(range)\n\n    if (range.isUnset) {\n      throw new Error('The range cannot be unset to calculcate its offset.')\n    }\n\n    if (range.isExpanded) {\n      throw new Error('The range must be collapsed to calculcate its offset.')\n    }\n\n    const { start } = range\n    const offset = this.getOffset(start.key) + start.offset\n    return offset\n  }\n\n  /**\n   * Get all of the marks for all of the characters of every text node.\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarks() {\n    const array = this.getMarksAsArray()\n    return OrderedSet(array)\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksAtRange(range) {\n    range = this.resolveRange(range)\n    const { start, end } = range\n\n    if (range.isUnset) {\n      return OrderedSet()\n    }\n\n    if (range.isCollapsed) {\n      // PERF: range is not cachable, use key and offset as proxies for cache\n      return this.getMarksAtPosition(start.key, start.offset)\n    }\n\n    const marks = this.getOrderedMarksBetweenPositions(\n      start.key,\n      start.offset,\n      end.key,\n      end.offset\n    )\n\n    return marks\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   * PERF: arguments use key and offset for utilizing cache\n   *\n   * @param {string} startKey\n   * @param {number} startOffset\n   * @param {string} endKey\n   * @param {number} endOffset\n   * @returns {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksBetweenPositions(startKey, startOffset, endKey, endOffset) {\n    if (startKey === endKey) {\n      const startText = this.getDescendant(startKey)\n      return startText.getMarksBetweenOffsets(startOffset, endOffset)\n    }\n\n    const texts = this.getTextsBetweenPositionsAsArray(startKey, endKey)\n\n    return OrderedSet().withMutations(result => {\n      texts.forEach(text => {\n        if (text.key === startKey) {\n          result.union(\n            text.getMarksBetweenOffsets(startOffset, text.text.length)\n          )\n        } else if (text.key === endKey) {\n          result.union(text.getMarksBetweenOffsets(0, endOffset))\n        } else {\n          result.union(text.getMarks())\n        }\n      })\n    })\n  }\n\n  /**\n   * Get all of the marks that match a `type`.\n   *\n   * @param {String} type\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksByType(type) {\n    const array = this.getMarksByTypeAsArray(type)\n    return OrderedSet(array)\n  }\n\n  /**\n   * Get the parent of a descendant node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getParent(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    const parentPath = PathUtils.lift(path)\n    const parent = this.getNode(parentPath)\n    return parent\n  }\n\n  /**\n   * Get the block node before a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getPreviousBlock(key) {\n    const child = this.assertDescendant(key)\n    let first\n\n    if (child.object == 'block') {\n      first = child.getFirstText()\n    } else {\n      const block = this.getClosestBlock(key)\n      first = block.getFirstText()\n    }\n\n    const previous = this.getPreviousText(first.key)\n    if (!previous) return null\n\n    const closest = this.getClosestBlock(previous.key)\n    return closest\n  }\n\n  /**\n   * Get the previous node from a node in the tree.\n   *\n   * This will not only check for siblings but instead move up the tree\n   * returning the previous ancestor if no sibling is found.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getPreviousNode(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n\n    for (let i = path.size; i > 0; i--) {\n      const p = path.slice(0, i)\n      if (p.last() === 0) continue\n\n      const target = PathUtils.decrement(p)\n      const node = this.getNode(target)\n      if (node) return node\n    }\n\n    return null\n  }\n\n  /**\n   * Get the previous sibling of a node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getPreviousSibling(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    if (path.last() === 0) return null\n    const p = PathUtils.decrement(path)\n    const sibling = this.getNode(p)\n    return sibling\n  }\n\n  /**\n   * Get the text node after a descendant text node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getPreviousText(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    const previous = this.getPreviousNode(path)\n    if (!previous) return null\n    const text = previous.getLastText()\n    return text\n  }\n\n  /**\n   * Get the indexes of the selection for a `range`, given an extra flag for\n   * whether the node `isSelected`, to determine whether not finding matches\n   * means everything is selected or nothing is.\n   *\n   * @param {Range} range\n   * @param {Boolean} isSelected\n   * @return {Object|Null}\n   */\n\n  getSelectionIndexes(range, isSelected = true) {\n    const { start, end } = range\n\n    // PERF: if we're not selected, we can exit early.\n    if (!isSelected) {\n      return null\n    }\n\n    // if we've been given an invalid selection we can exit early.\n    if (range.isUnset) {\n      return null\n    }\n\n    // PERF: if the start and end keys are the same, just check for the child\n    // that contains that single key.\n    if (start.key == end.key) {\n      const child = this.getFurthestAncestor(start.key)\n      const index = child ? this.nodes.indexOf(child) : null\n      return { start: index, end: index + 1 }\n    }\n\n    // Otherwise, check all of the children...\n    let startIndex = null\n    let endIndex = null\n\n    this.nodes.forEach((child, i) => {\n      if (child.object == 'text') {\n        if (startIndex == null && child.key == start.key) startIndex = i\n        if (endIndex == null && child.key == end.key) endIndex = i + 1\n      } else {\n        if (startIndex == null && child.hasDescendant(start.key)) startIndex = i\n        if (endIndex == null && child.hasDescendant(end.key)) endIndex = i + 1\n      }\n\n      // PERF: exit early if both start and end have been found.\n      return startIndex == null || endIndex == null\n    })\n\n    if (isSelected && startIndex == null) startIndex = 0\n    if (isSelected && endIndex == null) endIndex = this.nodes.size\n    return startIndex == null ? null : { start: startIndex, end: endIndex }\n  }\n\n  /**\n   * Get the descendent text node at an `offset`.\n   *\n   * @param {String} offset\n   * @return {Node|Null}\n   */\n\n  getTextAtOffset(offset) {\n    // PERF: Add a few shortcuts for the obvious cases.\n    if (offset === 0) return this.getFirstText()\n    if (offset === this.text.length) return this.getLastText()\n    if (offset < 0 || offset > this.text.length) return null\n\n    let length = 0\n    const text = this.getTexts().find((node, i, nodes) => {\n      length += node.text.length\n      return length > offset\n    })\n\n    return text\n  }\n\n  /**\n   * Get the direction of the node's text.\n   *\n   * @return {String}\n   */\n\n  getTextDirection() {\n    const dir = direction(this.text)\n    return dir === 'neutral' ? null : dir\n  }\n\n  /**\n   * Recursively get all of the child text nodes in order of appearance.\n   *\n   * @return {List<Node>}\n   */\n\n  getTexts() {\n    const array = this.getTextsAsArray()\n    return List(array)\n  }\n\n  /**\n   * Recursively get all the leaf text nodes in order of appearance, as array.\n   *\n   * @return {List<Node>}\n   */\n\n  getTextsAsArray() {\n    let array = []\n\n    this.nodes.forEach(node => {\n      if (node.object == 'text') {\n        array.push(node)\n      } else {\n        array = array.concat(node.getTextsAsArray())\n      }\n    })\n\n    return array\n  }\n\n  /**\n   * Get all of the text nodes in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getTextsAtRange(range) {\n    range = this.resolveRange(range)\n    if (range.isUnset) return List()\n    const { start, end } = range\n    const list = List(this.getTextsBetweenPositionsAsArray(start.key, end.key))\n\n    return list\n  }\n\n  /**\n   * Get all of the text nodes in a `range` as an array.\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getTextsAtRangeAsArray(range) {\n    range = this.resolveRange(range)\n    if (range.isUnset) return []\n    const { start, end } = range\n    const texts = this.getTextsBetweenPositionsAsArray(start.key, end.key)\n    return texts\n  }\n\n  /**\n   * Get all of the text nodes in a `range` as an array.\n   * PERF: use key in arguments for cache\n   *\n   * @param {string} startKey\n   * @param {string} endKey\n   * @returns {Array}\n   */\n\n  getTextsBetweenPositionsAsArray(startKey, endKey) {\n    const startText = this.getDescendant(startKey)\n\n    // PERF: the most common case is when the range is in a single text node,\n    // where we can avoid a lot of iterating of the tree.\n    if (startKey == endKey) return [startText]\n\n    const endText = this.getDescendant(endKey)\n    const texts = this.getTextsAsArray()\n    const start = texts.indexOf(startText)\n    const end = texts.indexOf(endText, start)\n    const ret = texts.slice(start, end + 1)\n    return ret\n  }\n\n  /**\n   * Check if the node has block children.\n   *\n   * @return {Boolean}\n   */\n\n  hasBlockChildren() {\n    return !!(this.nodes && this.nodes.find(n => n.object === 'block'))\n  }\n\n  /**\n   * Check if a child node exists.\n   *\n   * @param {List|String} path\n   * @return {Boolean}\n   */\n\n  hasChild(path) {\n    const child = this.getChild(path)\n    return !!child\n  }\n\n  /**\n   * Check if a node has inline children.\n   *\n   * @return {Boolean}\n   */\n\n  hasInlineChildren() {\n    return !!(\n      this.nodes &&\n      this.nodes.find(n => n.object === 'inline' || n.object === 'text')\n    )\n  }\n\n  /**\n   * Recursively check if a child node exists.\n   *\n   * @param {List|String} path\n   * @return {Boolean}\n   */\n\n  hasDescendant(path) {\n    const descendant = this.getDescendant(path)\n    return !!descendant\n  }\n\n  /**\n   * Check if a node has a void parent.\n   *\n   * @param {List|String} path\n   * @param {Schema} schema\n   * @return {Boolean}\n   */\n\n  hasVoidParent(path, schema) {\n    const closest = this.getClosestVoid(path, schema)\n    return !!closest\n  }\n\n  /**\n   * Insert a `node`.\n   *\n   * @param {List|String} path\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  insertNode(path, node) {\n    path = this.resolvePath(path)\n    const index = path.last()\n    const parentPath = PathUtils.lift(path)\n    let parent = this.assertNode(parentPath)\n    const nodes = parent.nodes.splice(index, 0, node)\n    parent = parent.set('nodes', nodes)\n    const ret = this.replaceNode(parentPath, parent)\n    return ret\n  }\n\n  /**\n   * Insert `text` at `offset` in node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {String} text\n   * @param {Set} marks\n   * @return {Node}\n   */\n\n  insertText(path, offset, text, marks) {\n    let node = this.assertDescendant(path)\n    path = this.resolvePath(path)\n    node = node.insertText(offset, text, marks)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Check whether the node is a leaf block.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafBlock() {\n    const { object, nodes } = this\n    const first = nodes.first()\n    return object === 'block' && first.object !== 'block'\n  }\n\n  /**\n   * Check whether the node is a leaf inline.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafInline() {\n    const { object, nodes } = this\n    const first = nodes.first()\n    return object === 'inline' && first.object !== 'inline'\n  }\n\n  /**\n   * Map all child nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} iterator\n   * @return {Node}\n   */\n\n  mapChildren(iterator) {\n    let { nodes } = this\n\n    nodes.forEach((node, i) => {\n      const ret = iterator(node, i, this.nodes)\n      if (ret !== node) nodes = nodes.set(ret.key, ret)\n    })\n\n    const ret = this.set('nodes', nodes)\n    return ret\n  }\n\n  /**\n   * Map all descendant nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} iterator\n   * @return {Node}\n   */\n\n  mapDescendants(iterator) {\n    let { nodes } = this\n\n    nodes.forEach((node, index) => {\n      let ret = node\n      if (ret.object !== 'text') ret = ret.mapDescendants(iterator)\n      ret = iterator(ret, index, this.nodes)\n      if (ret === node) return\n\n      nodes = nodes.set(index, ret)\n    })\n\n    const ret = this.set('nodes', nodes)\n    return ret\n  }\n\n  /**\n   * Merge a node backwards its previous sibling.\n   *\n   * @param {List|Key} path\n   * @return {Node}\n   */\n\n  mergeNode(path) {\n    const b = this.assertNode(path)\n    path = this.resolvePath(path)\n\n    if (path.last() === 0) {\n      throw new Error(\n        `Unable to merge node because it has no previous sibling: ${b}`\n      )\n    }\n\n    const withPath = PathUtils.decrement(path)\n    const a = this.assertNode(withPath)\n\n    if (a.object !== b.object) {\n      throw new Error(\n        `Unable to merge two different kinds of nodes: ${a} and ${b}`\n      )\n    }\n\n    const newNode =\n      a.object === 'text'\n        ? a.mergeText(b)\n        : a.set('nodes', a.nodes.concat(b.nodes))\n\n    let ret = this\n    ret = ret.removeNode(path)\n    ret = ret.removeNode(withPath)\n    ret = ret.insertNode(withPath, newNode)\n    return ret\n  }\n\n  /**\n   * Move a node by `path` to `newPath`.\n   *\n   * A `newIndex` can be provided when move nodes by `key`, to account for not\n   * being able to have a key for a location in the tree that doesn't exist yet.\n   *\n   * @param {List|Key} path\n   * @param {List|Key} newPath\n   * @param {Number} newIndex\n   * @return {Node}\n   */\n\n  moveNode(path, newPath, newIndex = 0) {\n    const node = this.assertNode(path)\n    path = this.resolvePath(path)\n    newPath = this.resolvePath(newPath, newIndex)\n\n    const newParentPath = PathUtils.lift(newPath)\n    this.assertNode(newParentPath)\n\n    const [p, np] = PathUtils.crop(path, newPath)\n    const position = PathUtils.compare(p, np)\n\n    // If the old path ends above and before a node in the new path, then\n    // removing it will alter the target, so we need to adjust the new path.\n    if (path.size < newPath.size && position === -1) {\n      newPath = PathUtils.decrement(newPath, 1, p.size - 1)\n    }\n\n    let ret = this\n    ret = ret.removeNode(path)\n    ret = ret.insertNode(newPath, node)\n    return ret\n  }\n\n  /**\n   * Attempt to \"refind\" a node by a previous `path`, falling back to looking\n   * it up by `key` again.\n   *\n   * @param {List|String} path\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  refindNode(path, key) {\n    const node = this.getDescendant(path)\n    const found = node && node.key === key ? node : this.getDescendant(key)\n    return found\n  }\n\n  /**\n   * Attempt to \"refind\" the path to a node by a previous `path`, falling back\n   * to looking it up by `key`.\n   *\n   * @param {List|String} path\n   * @param {String} key\n   * @return {List|Null}\n   */\n\n  refindPath(path, key) {\n    const node = this.getDescendant(path)\n    const found = node && node.key === key ? path : this.getPath(key)\n    return found\n  }\n\n  /**\n   * Remove mark from text at `offset` and `length` in node.\n   *\n   * @param {List} path\n   * @param {Number} offset\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Node}\n   */\n\n  removeMark(path, offset, length, mark) {\n    let node = this.assertDescendant(path)\n    path = this.resolvePath(path)\n    node = node.removeMark(offset, length, mark)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Remove a node.\n   *\n   * @param {List|String} path\n   * @return {Node}\n   */\n\n  removeNode(path) {\n    this.assertDescendant(path)\n    path = this.resolvePath(path)\n    const deep = path.flatMap(x => ['nodes', x])\n    const ret = this.deleteIn(deep)\n    return ret\n  }\n\n  /**\n   * Remove `text` at `offset` in node.\n   *\n   * @param {List|Key} path\n   * @param {Number} offset\n   * @param {String} text\n   * @return {Node}\n   */\n\n  removeText(path, offset, text) {\n    let node = this.assertDescendant(path)\n    node = node.removeText(offset, text.length)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Replace a `node` in the tree.\n   *\n   * @param {List|Key} path\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  replaceNode(path, node) {\n    path = this.resolvePath(path)\n\n    if (!path) {\n      throw new Error(\n        `Unable to replace a node because it could not be found in the first place: ${path}`\n      )\n    }\n\n    if (!path.size) return node\n    this.assertNode(path)\n    const deep = path.flatMap(x => ['nodes', x])\n    const ret = this.setIn(deep, node)\n    return ret\n  }\n\n  /**\n   * Resolve a `decoration`, relative to the node, ensuring that the keys and\n   * offsets in the decoration exist and that they are synced with the paths.\n   *\n   * @param {Decoration|Object} decoration\n   * @return {Decoration}\n   */\n\n  resolveDecoration(decoration) {\n    decoration = Decoration.create(decoration)\n    decoration = decoration.normalize(this)\n    return decoration\n  }\n\n  /**\n   * Resolve a `point`, relative to the node, ensuring that the keys and\n   * offsets in the point exist and that they are synced with the paths.\n   *\n   * @param {Point|Object} point\n   * @return {Point}\n   */\n\n  resolvePoint(point) {\n    point = Point.create(point)\n    point = point.normalize(this)\n    return point\n  }\n\n  /**\n   * Resolve a `range`, relative to the node, ensuring that the keys and\n   * offsets in the range exist and that they are synced with the paths.\n   *\n   * @param {Range|Object} range\n   * @return {Range}\n   */\n\n  resolveRange(range) {\n    range = Range.create(range)\n    range = range.normalize(this)\n    return range\n  }\n\n  /**\n   * Resolve a `selection`, relative to the node, ensuring that the keys and\n   * offsets in the selection exist and that they are synced with the paths.\n   *\n   * @param {Selection|Object} selection\n   * @return {Selection}\n   */\n\n  resolveSelection(selection) {\n    selection = Selection.create(selection)\n    selection = selection.normalize(this)\n    return selection\n  }\n\n  /**\n   * Set `properties` on a node.\n   *\n   * @param {List|String} path\n   * @param {Object} properties\n   * @return {Node}\n   */\n\n  setNode(path, properties) {\n    let node = this.assertNode(path)\n    node = node.merge(properties)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Set `properties` on `mark` on text at `offset` and `length` in node.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {Number} length\n   * @param {Mark} mark\n   * @param {Object} properties\n   * @return {Node}\n   */\n\n  setMark(path, offset, length, mark, properties) {\n    let node = this.assertNode(path)\n    node = node.updateMark(offset, length, mark, properties)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Split a node by `path` at `position` with optional `properties` to apply\n   * to the newly split node.\n   *\n   * @param {List|String} path\n   * @param {Number} position\n   * @param {Object} properties\n   * @return {Node}\n   */\n\n  splitNode(path, position, properties) {\n    const child = this.assertNode(path)\n    path = this.resolvePath(path)\n    let a\n    let b\n\n    if (child.object === 'text') {\n      ;[a, b] = child.splitText(position)\n    } else {\n      const befores = child.nodes.take(position)\n      const afters = child.nodes.skip(position)\n      a = child.set('nodes', befores)\n      b = child.set('nodes', afters).regenerateKey()\n    }\n\n    if (properties && child.object !== 'text') {\n      b = b.merge(properties)\n    }\n\n    let ret = this\n    ret = ret.removeNode(path)\n    ret = ret.insertNode(path, b)\n    ret = ret.insertNode(path, a)\n    return ret\n  }\n}\n\n/**\n * Mix in assertion variants.\n */\n\nconst ASSERTS = ['Child', 'Depth', 'Descendant', 'Node', 'Parent', 'Path']\n\nfor (const method of ASSERTS) {\n  ElementInterface.prototype[`assert${method}`] = function(path, ...args) {\n    const ret = this[`get${method}`](path, ...args)\n\n    if (ret == null) {\n      throw new Error(\n        `\\`Node.assert${method}\\` could not find node with path or key: ${path}`\n      )\n    }\n\n    return ret\n  }\n}\n\n/**\n * Memoize read methods.\n */\n\nmemoize(ElementInterface.prototype, [\n  'getBlocksAsArray',\n  'getBlocksAtRangeAsArray',\n  'getBlocksByTypeAsArray',\n  'getDecorations',\n  'getFragmentAtRange',\n  'getInlinesAsArray',\n  'getInlinesAtRangeAsArray',\n  'getInlinesByTypeAsArray',\n  'getMarksAsArray',\n  'getMarksAtPosition',\n  'getOrderedMarksBetweenPositions',\n  'getInsertMarksAtRange',\n  'getMarksByTypeAsArray',\n  'getNextBlock',\n  'getOffset',\n  'getOffsetAtRange',\n  'getPreviousBlock',\n  'getTextAtOffset',\n  'getTextDirection',\n  'getTextsAsArray',\n  'getTextsBetweenPositionsAsArray',\n])\n\n/**\n * Mix in the element interface.\n */\n\nmixin(ElementInterface, [Block, Document, Inline])\n","import warning from 'slate-dev-warning'\nimport { List } from 'immutable'\n\nimport mixin from '../utils/mixin'\nimport Block from '../models/block'\nimport Document from '../models/document'\nimport Inline from '../models/inline'\nimport KeyUtils from '../utils/key-utils'\nimport memoize from '../utils/memoize'\nimport PathUtils from '../utils/path-utils'\nimport Text from '../models/text'\n\n/**\n * The interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Class}\n */\n\nclass NodeInterface {\n  /**\n   * Get the concatenated text of the node.\n   *\n   * @return {String}\n   */\n\n  get text() {\n    return this.getText()\n  }\n\n  /**\n   * Check whether the node is a leaf inline.\n   *\n   * @return {Boolean}\n   */\n\n  getFirstInvalidNode(schema) {\n    if (this.object === 'text') {\n      const invalid = this.validate(schema) ? this : null\n      return invalid\n    }\n\n    let invalid = null\n\n    this.nodes.find(n => {\n      invalid = n.validate(schema) ? n : n.getFirstInvalidNode(schema)\n      return invalid\n    })\n\n    return invalid\n  }\n\n  /**\n   * Get the first text node of a node, or the node itself.\n   *\n   * @return {Node|Null}\n   */\n\n  getFirstText() {\n    if (this.object === 'text') {\n      return this\n    }\n\n    let descendant = null\n\n    const found = this.nodes.find(node => {\n      if (node.object === 'text') return true\n      descendant = node.getFirstText()\n      return !!descendant\n    })\n\n    return descendant || found\n  }\n\n  /**\n   * Get an object mapping all the keys in the node to their paths.\n   *\n   * @return {Object}\n   */\n\n  getKeysToPathsTable() {\n    const ret = {\n      [this.key]: [],\n    }\n\n    if (this.nodes) {\n      this.nodes.forEach((node, i) => {\n        const nested = node.getKeysToPathsTable()\n\n        for (const key in nested) {\n          const path = nested[key]\n\n          warning(\n            !(key in ret),\n            `A node with a duplicate key of \"${key}\" was found! Duplicate keys are not allowed, you should use \\`node.regenerateKey\\` before inserting if you are reusing an existing node.`\n          )\n\n          ret[key] = [i, ...path]\n        }\n      })\n    }\n\n    return ret\n  }\n\n  /**\n   * Get the last text node of a node, or the node itself.\n   *\n   * @return {Node|Null}\n   */\n\n  getLastText() {\n    if (this.object === 'text') {\n      return this\n    }\n\n    let descendant = null\n\n    const found = this.nodes.findLast(node => {\n      if (node.object == 'text') return true\n      descendant = node.getLastText()\n      return descendant\n    })\n\n    return descendant || found\n  }\n\n  /**\n   * Get a node in the tree, or the node itself.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNode(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (this.object === 'text' && path.size) return null\n    const node = path.size ? this.getDescendant(path) : this\n    return node\n  }\n\n  /**\n   * Find the path to a node.\n   *\n   * @param {String|List} key\n   * @return {List}\n   */\n\n  getPath(key) {\n    // Handle the case of passing in a path directly, to match other methods.\n    if (List.isList(key)) return key\n\n    const dict = this.getKeysToPathsTable()\n    const path = dict[key]\n    return path ? List(path) : null\n  }\n\n  /**\n   * Get the concatenated text string of a node.\n   *\n   * @return {String}\n   */\n\n  getText() {\n    const children = this.object === 'text' ? this.leaves : this.nodes\n    const text = children.reduce((memo, c) => memo + c.text, '')\n    return text\n  }\n\n  /**\n   * Check if a node exists.\n   *\n   * @param {List|String} path\n   * @return {Boolean}\n   */\n\n  hasNode(path) {\n    const node = this.getNode(path)\n    return !!node\n  }\n\n  /**\n   * Normalize the text node with a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Function|Void}\n   */\n\n  normalize(schema) {\n    const normalizer = schema.normalizeNode(this)\n    return normalizer\n  }\n\n  /**\n   * Regenerate the node's key.\n   *\n   * @return {Node}\n   */\n\n  regenerateKey() {\n    const key = KeyUtils.create()\n    const node = this.set('key', key)\n    return node\n  }\n\n  /**\n   * Resolve a path from a path list or key string.\n   *\n   * An `index` can be provided, in which case paths created from a key string\n   * will have the index pushed onto them. This is helpful in cases where you\n   * want to accept either a `path` or a `key, index` combination for targeting\n   * a location in the tree that doesn't exist yet, like when inserting.\n   *\n   * @param {List|String} value\n   * @param {Number} index\n   * @return {List}\n   */\n\n  resolvePath(path, index) {\n    if (typeof path === 'string') {\n      path = this.getPath(path)\n\n      if (index != null) {\n        path = path.concat(index)\n      }\n    } else {\n      path = PathUtils.create(path)\n    }\n\n    return path\n  }\n\n  /**\n   * Validate the node against a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Error|Void}\n   */\n\n  validate(schema) {\n    const error = schema.validateNode(this)\n    return error\n  }\n}\n\n/**\n * Memoize read methods.\n */\n\nmemoize(NodeInterface.prototype, [\n  'getFirstInvalidNode',\n  'getFirstText',\n  'getKeysToPathsTable',\n  'getLastText',\n  'getText',\n  'normalize',\n  'validate',\n])\n\n/**\n * Mix in the node interface.\n */\n\nmixin(NodeInterface, [Block, Document, Inline, Text])\n","import mixin from '../utils/mixin'\nimport Decoration from '../models/decoration'\nimport PathUtils from '../utils/path-utils'\nimport Point from '../models/point'\nimport Range from '../models/range'\nimport Selection from '../models/selection'\n\n/**\n * The interface that `Decoration`, `Range` and `Selection` all implement, to make\n * working anchor and focus points easier.\n *\n * @type {Class}\n */\n\nclass RangeInterface {\n  /**\n   * Check whether the range is collapsed.\n   *\n   * @return {Boolean}\n   */\n\n  get isCollapsed() {\n    return (\n      this.anchor === this.focus ||\n      (this.anchor.key === this.focus.key &&\n        this.anchor.offset === this.focus.offset)\n    )\n  }\n\n  /**\n   * Check whether the range is expanded.\n   *\n   * @return {Boolean}\n   */\n\n  get isExpanded() {\n    return !this.isCollapsed\n  }\n\n  /**\n   * Check whether the range is backward.\n   *\n   * @return {Boolean}\n   */\n\n  get isBackward() {\n    const { isUnset, anchor, focus } = this\n\n    if (isUnset) {\n      return null\n    }\n\n    if (anchor.key === focus.key) {\n      return anchor.offset > focus.offset\n    }\n\n    const isBackward = PathUtils.isBefore(focus.path, anchor.path)\n    return isBackward\n  }\n\n  /**\n   * Check whether the range is forward.\n   *\n   * @return {Boolean}\n   */\n\n  get isForward() {\n    const { isBackward } = this\n    const isForward = isBackward == null ? null : !isBackward\n    return isForward\n  }\n\n  /**\n   * Check whether the range isn't set.\n   *\n   * @return {Boolean}\n   */\n\n  get isUnset() {\n    const { anchor, focus } = this\n    const isUnset = anchor.isUnset || focus.isUnset\n    return isUnset\n  }\n\n  /**\n   * Check whether the range is set.\n   *\n   * @return {Boolean}\n   */\n\n  get isSet() {\n    return !this.isUnset\n  }\n\n  /**\n   * Get the start point.\n   *\n   * @return {String}\n   */\n\n  get start() {\n    return this.isBackward ? this.focus : this.anchor\n  }\n\n  /**\n   * Get the end point.\n   *\n   * @return {String}\n   */\n\n  get end() {\n    return this.isBackward ? this.anchor : this.focus\n  }\n\n  /**\n   * Flip the range.\n   *\n   * @return {Range}\n   */\n\n  flip() {\n    const range = this.setPoints([this.focus, this.anchor])\n    return range\n  }\n\n  /**\n   * Move the anchor and focus offsets forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveForward(n) {\n    return this.updatePoints(point => point.moveForward(n))\n  }\n\n  /**\n   * Move the anchor and focus offsets backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveBackward(n) {\n    return this.updatePoints(point => point.moveBackward(n))\n  }\n\n  /**\n   * Move the anchor offset backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveAnchorBackward(n) {\n    const range = this.setAnchor(this.anchor.moveBackward(n))\n    return range\n  }\n\n  /**\n   * Move the anchor offset forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveAnchorForward(n) {\n    const range = this.setAnchor(this.anchor.moveForward(n))\n    return range\n  }\n\n  /**\n   * Move the range's anchor point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveAnchorTo(path, offset) {\n    const range = this.setAnchor(this.anchor.moveTo(path, offset))\n    return range\n  }\n\n  /**\n   * Move the range's anchor point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveAnchorToStartOfNode(node) {\n    const range = this.setAnchor(this.anchor.moveToStartOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the range's anchor point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveAnchorToEndOfNode(node) {\n    const range = this.setAnchor(this.anchor.moveToEndOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the end offset backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveEndBackward(n) {\n    const range = this.setEnd(this.end.moveBackward(n))\n    return range\n  }\n\n  /**\n   * Move the end offset forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveEndForward(n) {\n    const range = this.setEnd(this.end.moveForward(n))\n    return range\n  }\n\n  /**\n   * Move the range's end point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveEndTo(path, offset) {\n    const range = this.setEnd(this.end.moveTo(path, offset))\n    return range\n  }\n\n  /**\n   * Move the range's end point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveEndToStartOfNode(node) {\n    const range = this.setEnd(this.end.moveToStartOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the range's end point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveEndToEndOfNode(node) {\n    const range = this.setEnd(this.end.moveToEndOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the focus offset backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveFocusBackward(n) {\n    const range = this.setFocus(this.focus.moveBackward(n))\n    return range\n  }\n\n  /**\n   * Move the focus offset forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveFocusForward(n) {\n    const range = this.setFocus(this.focus.moveForward(n))\n    return range\n  }\n\n  /**\n   * Move the range's focus point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveFocusTo(path, offset) {\n    const range = this.setFocus(this.focus.moveTo(path, offset))\n    return range\n  }\n\n  /**\n   * Move the range's focus point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveFocusToStartOfNode(node) {\n    const range = this.setFocus(this.focus.moveToStartOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the range's focus point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveFocusToEndOfNode(node) {\n    const range = this.setFocus(this.focus.moveToEndOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the start offset backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveStartBackward(n) {\n    const range = this.setStart(this.start.moveBackward(n))\n    return range\n  }\n\n  /**\n   * Move the start offset forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveStartForward(n) {\n    const range = this.setStart(this.start.moveForward(n))\n    return range\n  }\n\n  /**\n   * Move the range's start point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveStartTo(path, offset) {\n    const range = this.setStart(this.start.moveTo(path, offset))\n    return range\n  }\n\n  /**\n   * Move the range's start point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveStartToStartOfNode(node) {\n    const range = this.setStart(this.start.moveToStartOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the range's start point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveStartToEndOfNode(node) {\n    const range = this.setStart(this.start.moveToEndOfNode(node))\n    return range\n  }\n\n  /**\n   * Move range's points to a new `path` and `offset`.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveTo(path, offset) {\n    return this.updatePoints(point => point.moveTo(path, offset))\n  }\n\n  /**\n   * Move the focus point to the anchor point.\n   *\n   * @return {Range}\n   */\n\n  moveToAnchor() {\n    const range = this.setFocus(this.anchor)\n    return range\n  }\n\n  /**\n   * Move the start point to the end point.\n   *\n   * @return {Range}\n   */\n\n  moveToEnd() {\n    const range = this.setStart(this.end)\n    return range\n  }\n\n  /**\n   * Move the range's points to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveToEndOfNode(node) {\n    return this.updatePoints(point => point.moveToEndOfNode(node))\n  }\n\n  /**\n   * Move the anchor point to the focus point.\n   *\n   * @return {Range}\n   */\n\n  moveToFocus() {\n    const range = this.setAnchor(this.focus)\n    return range\n  }\n\n  /**\n   * Move to the entire range of `start` and `end` nodes.\n   *\n   * @param {Node} start\n   * @param {Node} end (optional)\n   * @return {Range}\n   */\n\n  moveToRangeOfNode(start, end = start) {\n    const range = this.setPoints([\n      this.anchor.moveToStartOfNode(start),\n      this.focus.moveToEndOfNode(end),\n    ])\n\n    return range\n  }\n\n  /**\n   * Move the end point to the start point.\n   *\n   * @return {Range}\n   */\n\n  moveToStart() {\n    const range = this.setEnd(this.start)\n    return range\n  }\n\n  /**\n   * Move the range's points to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveToStartOfNode(node) {\n    return this.updatePoints(point => point.moveToStartOfNode(node))\n  }\n\n  /**\n   * Normalize the range, relative to a `node`, ensuring that the anchor\n   * and focus nodes of the range always refer to leaf text nodes.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  normalize(node) {\n    return this.updatePoints(point => point.normalize(node))\n  }\n\n  /**\n   * Set the anchor point to a new `anchor`.\n   *\n   * @param {Point} anchor\n   * @return {Range}\n   */\n\n  setAnchor(anchor) {\n    const range = this.set('anchor', anchor)\n    return range\n  }\n\n  /**\n   * Set the end point to a new `point`.\n   *\n   * @param {Point} point\n   * @return {Range}\n   */\n\n  setEnd(point) {\n    const range = this.isBackward ? this.setAnchor(point) : this.setFocus(point)\n    return range\n  }\n\n  /**\n   * Set the focus point to a new `focus`.\n   *\n   * @param {Point} focus\n   * @return {Range}\n   */\n\n  setFocus(focus) {\n    const range = this.set('focus', focus)\n    return range\n  }\n\n  /**\n   * Set the anchor and focus points to new `values`.\n   *\n   * @param {Array<Point>} values\n   * @return {Range}\n   */\n\n  setPoints(values) {\n    const [anchor, focus] = values\n    const range = this.set('anchor', anchor).set('focus', focus)\n    return range\n  }\n\n  /**\n   * Set the anchor and focus points with `updater` callback\n   *\n   * @param {Function} updater\n   * @return {Range}\n   */\n\n  updatePoints(updater) {\n    let { anchor, focus } = this\n    anchor = updater(anchor)\n    focus = updater(focus)\n    return this.merge({ anchor, focus })\n  }\n\n  /**\n   * Set the start point to a new `point`.\n   *\n   * @param {Point} point\n   * @return {Range}\n   */\n\n  setStart(point) {\n    const range = this.isBackward ? this.setFocus(point) : this.setAnchor(point)\n    return range\n  }\n\n  /**\n   * Set new `properties` on the range.\n   *\n   * @param {Object|Range} properties\n   * @return {Range}\n   */\n\n  setProperties(properties) {\n    properties = Range.createProperties(properties)\n    const { anchor, focus, ...props } = properties\n\n    if (anchor) {\n      props.anchor = Point.create(anchor)\n    }\n\n    if (focus) {\n      props.focus = Point.create(focus)\n    }\n\n    const range = this.merge(props)\n    return range\n  }\n\n  /**\n   * Return a JSON representation of the range.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n    }\n\n    return object\n  }\n\n  /**\n   * Return a `Range` instance from any range-like instance.\n   *\n   * @return {Range}\n   */\n\n  toRange() {\n    const properties = Range.createProperties(this)\n    const range = Range.create(properties)\n    return range\n  }\n\n  /**\n   * Unset the range.\n   *\n   * @return {Range}\n   */\n\n  unset() {\n    const range = this.updatePoints(p => p.unset())\n    return range\n  }\n}\n\n/**\n * Mix in the range interface.\n *\n * @param {Record}\n */\n\nmixin(RangeInterface, [Decoration, Range, Selection])\n","import apply from './apply'\nimport invert from './invert'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  apply,\n  invert,\n}\n","import './interfaces/common'\nimport './interfaces/element'\nimport './interfaces/node'\nimport './interfaces/range'\n\nimport Block from './models/block'\nimport Change from './models/change'\nimport Changes from './changes'\nimport Data from './models/data'\nimport Decoration from './models/decoration'\nimport Document from './models/document'\nimport History from './models/history'\nimport Inline from './models/inline'\nimport KeyUtils from './utils/key-utils'\nimport Leaf from './models/leaf'\nimport Mark from './models/mark'\nimport Node from './models/node'\nimport Operation from './models/operation'\nimport Operations from './operations'\nimport PathUtils from './utils/path-utils'\nimport Point from './models/point'\nimport Range from './models/range'\nimport Schema from './models/schema'\nimport Selection from './models/selection'\nimport Stack from './models/stack'\nimport Text from './models/text'\nimport TextUtils from './utils/text-utils'\nimport Value from './models/value'\nimport { resetMemoization, useMemoization } from './utils/memoize'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport {\n  Block,\n  Change,\n  Changes,\n  Data,\n  Decoration,\n  Document,\n  History,\n  Inline,\n  KeyUtils,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  Operations,\n  PathUtils,\n  Point,\n  Range,\n  resetMemoization,\n  Schema,\n  Selection,\n  Stack,\n  Text,\n  TextUtils,\n  useMemoization,\n  Value,\n}\n\nexport default {\n  Block,\n  Changes,\n  Data,\n  Decoration,\n  Document,\n  History,\n  Inline,\n  KeyUtils,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  Operations,\n  PathUtils,\n  Point,\n  Range,\n  resetMemoization,\n  Schema,\n  Selection,\n  Stack,\n  Text,\n  TextUtils,\n  useMemoization,\n  Value,\n}\n"],"names":["mixin","Interface","Classes","Class","Object","getOwnPropertyNames","name","hasOwnProperty","desc","getOwnPropertyDescriptor","defineProperty","prototype","n","generate","create","key","Error","setGenerator","func","resetGenerator","MODEL_TYPES","isType","type","any","Data","attrs","Map","isMap","isPlainObject","fromJSON","object","fromJS","DEFAULTS","undefined","List","Document","options","data","toJSON","nodes","toArray","map","preserveKeys","isDocument","isList","Array","isArray","KeyUtils","document","Node","createList","Record","bind","DOCUMENT","Inline","isInline","elements","list","inline","every","item","INLINE","Mark","isMark","Set","isSet","marks","props","mark","MARK","Leaf","newMark","equals","has","newMarks","withMutations","remove","add","set","union","text","m","isLeaf","leaves","size","invalid","result","findLast","leaf","index","firstLeaf","cache","first","unshift","offset","endOffset","left","right","find","startOffset","length","slice","of","take","skip","push","LEAF","ENABLED","CACHE_KEY","UNDEFINED","UNSET","memoize","properties","property","original","args","apply","__cache_key","__cache","__cache_no_args","takesArguments","cachedValue","keys","getIn","value","v","setIn","get","parent","child","resetMemoization","Number","MAX_SAFE_INTEGER","useMemoization","enabled","Text","l","addMarks","newFirst","splitLeaves","before","bundle","middle","after","concat","x","setLeaves","decorations","forEach","start","dec","end","hasStart","hasEnd","addMark","createLeaves","getActiveMarks","leafEnd","leafStart","intersect","c","getMarks","array","getMarksAsArray","OrderedSet","searchLeafAtOffset","delta","beforeText","afterText","nextLeaves","splice","removeMark","getLeaves","r","merge","updateMark","splitted","one","two","regenerateKey","isText","ranges","node","TEXT","isNode","kind","Block","isBlock","block","BLOCK","Changes","PROXY_TRANSFORMS","method","change","selection","methodAtRange","match","moveToStart","moveToEnd","isExpanded","addMarkAtRange","sel","select","getActiveMarksAtRange","delete","deleteAtRange","insertBlock","insertBlockAtRange","getNode","moveToEndOfNode","insertFragment","fragment","startText","endText","startInline","lastText","getLastText","lastInline","getClosestInline","firstChild","lastChild","last","getTexts","isAppending","isAtStartOfNode","isAtEndOfNode","isInserting","hasBlockChildren","insertFragmentAtRange","newTexts","filter","includes","newText","takeLast","moveToStartOfNode","moveForward","insertInline","insertInlineAtRange","insertText","getInsertMarksAtRange","insertTextAtRange","removeMarkAtRange","replaceMark","oldMark","splitBlock","depth","splitBlockAtRange","toggleMark","exists","activeMarks","wrapText","prefix","suffix","wrapTextAtRange","isCollapsed","moveStartBackward","moveEndBackward","isForward","flip","SURROGATE_START","SURROGATE_END","SPACE","CHAMELEON","PUNCTUATION","isSurrogate","code","isWord","char","remaining","test","next","charAt","getCharLength","rest","charCodeAt","getCharOffset","getCharOffsetBackward","reverse","getCharOffsetForward","getWordOffset","i","started","getWordOffsetBackward","o","getWordOffsetForward","range","normalize","getFlag","texts","getTextsAtRange","addMarkByKey","addMarksAtRange","snapshotSelection","startKey","endKey","schema","isStartVoid","hasVoidParent","isEndVoid","startBlock","getClosestBlock","endBlock","isHanging","getFirstText","prevText","getPreviousText","startVoid","getClosestVoid","nextText","getNextText","removeNodeByKey","endVoid","removeTextByKey","startLength","endLength","ancestor","getCommonAncestor","startChild","getFurthestAncestor","endChild","startParent","getParent","startParentIndex","indexOf","endParentIndex","afters","startChildIndex","endChildIndex","middles","befores","lonely","getFurthestOnlyChildAncestor","moveNodeByKey","mergeNodeByKey","normalizeNodeByKey","deleteCharBackwardAtRange","getOffset","TextUtils","deleteBackwardAtRange","deleteLineBackwardAtRange","deleteWordBackwardAtRange","focus","voidParent","isVoid","getDescendant","prev","prevBlock","prevVoid","moveAnchorTo","moveFocusBackward","traversed","deleteCharForwardAtRange","deleteForwardAtRange","deleteLineForwardAtRange","deleteWordForwardAtRange","nextBlock","getNextBlock","nextVoid","moveFocusTo","moveFocusForward","extra","insertNodeByKey","atEnd","siblingText","splitRange","splitDescendantsByKey","moveTo","mapDescendants","isAtStart","blocks","getBlocks","firstBlock","lastBlock","lonelyParent","getFurthest","p","lonelyChild","startIndex","removeNode","newIndex","nextChild","getNextSibling","nextNodes","skipUntil","lastIndex","inlineChild","inlineIndex","assertDescendant","splitNodeByKey","insertTextByKey","commonAncestor","ancestors","getAncestors","normalizeAncestor","normalizeKey","removeMarkByKey","setBlocksAtRange","getBlocksAtRange","sets","setNodeByKey","setInlinesAtRange","inlines","getInlinesAtRange","height","h","isBackward","moveAnchorToStartOfNode","setFocus","setPath","anchor","resolveRange","splitInlineAtRange","Infinity","toggleMarkAtRange","some","unwrapBlockAtRange","createProperties","wrappers","getClosest","isSuperset","toOrderedSet","toList","children","b","hasDescendant","firstMatch","lastMatch","takeUntil","firstText","normalizeDocument","unwrapInlineAtRange","wrapBlockAtRange","clear","firstblock","lastblock","siblings","p1","p2","indexes","reduce","ind","wrapInlineAtRange","inlineParent","wrapInlineByKey","endInline","endIndex","splitText","inlinekey","rng","startInner","startInnerIndex","endInner","startInlines","endInlines","startNode","endNode","startRange","endRange","compare","path","target","pv","tv","crop","a","min","ca","cb","decrement","increment","newValue","newPath","isAbove","t","isAfter","isBefore","lift","max","Math","relate","av","bv","addMarkByPath","assertNode","operations","bx","by","ax","ay","applyOperations","normalizeParentByPath","insertFragmentByPath","insertNodeByPath","normalizeNodeByPath","applyOperation","insertTextByPath","getMarksAtIndex","mergeNodeByPath","previous","getPreviousSibling","position","moveNodeByPath","ancestorPath","PathUtils","removeMarkByPath","removeAllMarksByPath","state","getTextsAsArray","removeNodeByPath","removeTextByPath","removals","string","replaceNodeByPath","newNode","parentPath","replaceTextByPath","createRange","activeMark","setMarkByPath","setNodeByPath","setTextByPath","splitNodeByPath","splitDescendantsByPath","textPath","textOffset","prevIndex","unwrapInlineByPath","moveToRangeOfNode","unwrapBlockByPath","unwrapNodeByPath","parentIndex","grandPath","isFirst","isLast","updatedPath","wrapBlockByPath","wrapInlineByPath","wrapNodeByPath","CHANGES","assertPath","newKey","textKey","Point","isUnset","is","hasNode","point","setOffset","moveBackward","getPath","getTextAtOffset","isPoint","obj","POINT","Decoration","decoration","isDecoration","Range","isRange","DECORATION","RANGE","Selection","isSelection","isFocused","createSet","SELECTION","debug","Debug","Stack","History","operation","history","undos","redos","prevBatch","peek","prevOperation","shouldMerge","batch","pop","isHistory","createOperationsList","HISTORY","plugins","plugin","getPluginsWith","ret","reduceRight","stack","STACK","SlateError","captureStackTrace","constructor","CORE_RULES","error","Schema","rules","testRules","getNodeRules","failure","validateRules","validateNode","rule","isAtomic","isSchema","SCHEMA","defaultNormalize","validateObject","validateType","validateData","validateMarks","validateText","validateFirst","validateLast","validateNodes","fail","fn","valid","def","replace","defs","nextDef","shift","rewind","err","validateParent","validatePrevious","validateNext","Value","Change","insertNode","mapRanges","updatePoints","moveAnchorForward","clearAtomicRanges","newDocument","mergeNode","resolvePath","withPath","moveNode","moveStartTo","unset","moveEndTo","removeText","rangeOffset","moveAnchorBackward","setNode","setMark","d","resolveDecoration","setProperties","resolveSelection","splitNode","iterator","createSelection","decs","createDecoration","from","to","preserveData","preserveDecorations","preserveHistory","preserveSelection","preserveSchema","getPreviousBlock","getNextInline","getPreviousInline","getMarksAtRange","getFragmentAtRange","isValue","save","VALUE","OPERATION_ATTRIBUTES","Operation","json","ATTRIBUTES","toJS","isOperation","OPERATION","invertOperation","op","inverse","inversePath","inverseNewPath","pathLast","newPathLast","e","inverseNode","inverseProperties","pick","inverseMark","inverseSelection","inverseProps","inverseValue","redo","omit","undo","invert","blur","deselect","call","proxy","pointBackward","pointForward","moveAnchorToEndOfBlock","pointEdgeObject","moveAnchorToEndOfInline","moveAnchorToEndOfDocument","moveAnchorToEndOfNode","moveToAnchor","moveAnchorToEndOfNextBlock","pointEdgeSideObject","moveAnchorToEndOfNextInline","moveAnchorToEndOfNextText","moveAnchorToEndOfPreviousBlock","moveAnchorToEndOfPreviousInline","moveAnchorToEndOfPreviousText","moveAnchorToEndOfText","moveAnchorToStartOfBlock","moveAnchorToStartOfDocument","moveAnchorToStartOfInline","moveAnchorToStartOfNextBlock","moveAnchorToStartOfNextInline","moveAnchorToStartOfNextText","moveAnchorToStartOfPreviousBlock","moveAnchorToStartOfPreviousInline","moveAnchorToStartOfPreviousText","moveAnchorToStartOfText","moveEndForward","moveEndToEndOfBlock","moveEndToEndOfDocument","moveEndToEndOfNode","moveEndToEndOfInline","moveEndToEndOfNextBlock","moveEndToEndOfNextInline","moveEndToEndOfNextText","moveEndToEndOfPreviousBlock","moveEndToEndOfPreviousInline","moveEndToEndOfPreviousText","moveEndToEndOfText","moveEndToStartOfBlock","moveEndToStartOfDocument","moveEndToStartOfNode","moveEndToStartOfInline","moveEndToStartOfNextBlock","moveEndToStartOfNextInline","moveEndToStartOfNextText","moveEndToStartOfPreviousBlock","moveEndToStartOfPreviousInline","moveEndToStartOfPreviousText","moveEndToStartOfText","moveFocusToEndOfBlock","moveFocusToEndOfDocument","moveFocusToEndOfNode","moveToFocus","moveFocusToEndOfInline","moveFocusToEndOfNextBlock","moveFocusToEndOfNextInline","moveFocusToEndOfNextText","moveFocusToEndOfPreviousBlock","moveFocusToEndOfPreviousInline","moveFocusToEndOfPreviousText","moveFocusToEndOfText","moveFocusToStartOfBlock","moveFocusToStartOfDocument","moveFocusToStartOfNode","moveFocusToStartOfInline","moveFocusToStartOfNextBlock","moveFocusToStartOfNextInline","moveFocusToStartOfNextText","moveFocusToStartOfPreviousBlock","moveFocusToStartOfPreviousInline","moveFocusToStartOfPreviousText","moveFocusToStartOfText","moveStartForward","moveStartToEndOfBlock","moveStartToEndOfDocument","moveStartToEndOfNode","moveStartToEndOfInline","moveStartToEndOfNextBlock","moveStartToEndOfNextInline","moveStartToEndOfNextText","moveStartToEndOfPreviousBlock","moveStartToEndOfPreviousInline","moveStartToEndOfPreviousText","moveStartToEndOfText","moveStartToStartOfBlock","moveStartToStartOfDocument","moveStartToStartOfNode","moveStartToStartOfInline","moveStartToStartOfNextBlock","moveStartToStartOfNextInline","moveStartToStartOfNextText","moveStartToStartOfPreviousBlock","moveStartToStartOfPreviousInline","moveStartToStartOfPreviousText","moveStartToStartOfText","moveToEndOfBlock","moveToEndOfDocument","moveToEndOfInline","moveToEndOfNextBlock","moveToEndOfNextInline","moveToEndOfNextText","moveToEndOfPreviousBlock","moveToEndOfPreviousInline","moveToEndOfPreviousText","moveToEndOfText","moveToRangeOfDocument","moveToStartOfBlock","moveToStartOfDocument","moveToStartOfInline","moveToStartOfNextBlock","moveToStartOfNextInline","moveToStartOfNextText","moveToStartOfPreviousBlock","moveToStartOfPreviousInline","moveToStartOfPreviousText","moveToStartOfText","snapshot","k","setAnchor","setEnd","setStart","edge","toUpperCase","Edge","side","Side","getDirectionNode","isInBlock","isPreviousInVoid","isNextInVoid","setValue","normalizeAncestorsByKey","normalizeParentByKey","normalizeNodeAndChildren","getFirstInvalidNode","refindNode","refindPath","normalizeNode","iterations","iterate","AtCurrentRange","AtRange","ByPath","OnHistory","OnSelection","OnValue","WithSchema","setSelection","flags","setOperationFlag","isChange","CHANGE","CommonInterface","ElementInterface","replaceNode","resolvePoint","matches","forEachDescendant","found","getMarksAtPosition","toSet","getActiveMarksBetweenOffsets","startMarks","endMarks","current","getBlocksAsArray","isLeafBlock","getBlocksAtRangeAsArray","getBlocksByTypeAsArray","closest","startAt","deep","flatMap","targetPath","targetPosition","mode","furthest","getInlinesAsArray","isLeafInline","getInlinesAtRangeAsArray","getTextsAtRangeAsArray","getInlinesByTypeAsArray","currentMarks","closestBlock","getOrderedMarksAtRange","getMarksByTypeAsArray","memo","sibling","getNextNode","hasChild","getOrderedMarksBetweenPositions","getMarksBetweenOffsets","getTextsBetweenPositionsAsArray","getPreviousNode","isSelected","dir","direction","getChild","descendant","mergeText","newParentPath","np","deleteIn","ASSERTS","NodeInterface","validate","nested","getKeysToPathsTable","dict","normalizer","getText","RangeInterface","setPoints","values","updater"],"mappings":"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"}